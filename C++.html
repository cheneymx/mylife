<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-07-03 Sat 22:39 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Lizhuo Chen" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="https://sandyuraz.com/styles/org.min.css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4cd9307">1. Standard Input and Output Objects</a></li>
<li><a href="#orgddba549">2. Variables and Basic Types</a></li>
<li><a href="#org2733261">3. Library Types</a></li>
<li><a href="#org122b0bf">4. Expressions</a></li>
<li><a href="#org3f68d35">5. Statements</a></li>
<li><a href="#org69808cc">6. Functions</a></li>
<li><a href="#org6a36cd4">7. The IO Library</a></li>
<li><a href="#org456a700">8. Sequential Containers</a></li>
<li><a href="#org580a135">9. Associative Containers</a></li>
<li><a href="#org338a30b">10. Classes</a></li>
<li><a href="#org37cbad4">11. Copy Control</a></li>
<li><a href="#org9d445e4">12. Object-Oriented Programming</a></li>
<li><a href="#org275e6f1">13. Template Definitions</a></li>
<li><a href="#orga5ecc9a">14. Namespaces</a></li>
<li><a href="#org36eafd0">15. update</a></li>
<li><a href="#org3a9fe53">16. updated</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4cd9307" class="outline-2">
<h2 id="org4cd9307"><span class="section-number-2">1</span> Standard Input and Output Objects</h2>
<div class="outline-text-2" id="text-1">
<p>
The library <b><b>iostream</b></b> library defines four IO objects: cin, cout, cerr, clog.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"Enter two numbers:"</span> &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">v1</span>, <span style="color: #7fffd4; font-weight: bold;">v2</span>;
<span style="color: #7fffd4;">std</span>::cin &gt;&gt; v1 &gt;&gt; v2;
</pre>
</div>

<p>
<b>endl</b> is a special value, called a <b><b>manipulator</b></b>, that when written to an output stream has the
effect of <b><b>writing a newline</b></b> to the output and <b><b>flushing the buffer</b></b> associated with that device.
</p>

<p>
Beware: Programmers often insert print statements during debugging. Such statements should
<b><b>always flush the stream</b></b>. Forgetting to do so may cause output to be left in the buffer if the
program crashes, leading to incorrect inferences about where the program crashed.
</p>

<p>
This program uses <b><b>std::cout</b></b> and <b><b>std::endl</b></b> rather than just cout and endl. The prefix <b><b>std::</b></b>
indicates that the names cout and endl are defined inside the <b><b>namespace</b></b> named <b><b>std</b></b>. Namespaces
allow programmers to avoid inadvertent collisions with the same names defined by a library.
</p>
</div>
</div>

<div id="outline-container-orgddba549" class="outline-2">
<h2 id="orgddba549"><span class="section-number-2">2</span> Variables and Basic Types</h2>
<div class="outline-text-2" id="text-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Meaning</th>
<th scope="col" class="org-left">Minimum Size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bool</td>
<td class="org-left">boolean</td>
<td class="org-left">NA</td>
</tr>

<tr>
<td class="org-left">char</td>
<td class="org-left">character</td>
<td class="org-left">8 bits</td>
</tr>

<tr>
<td class="org-left">wchar<sub>t</sub></td>
<td class="org-left">wide character(eg. Chinese)</td>
<td class="org-left">16 bits</td>
</tr>

<tr>
<td class="org-left">short</td>
<td class="org-left">short integer</td>
<td class="org-left">16 bits</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-left">integer</td>
<td class="org-left">16 bits</td>
</tr>

<tr>
<td class="org-left">long</td>
<td class="org-left">long integer</td>
<td class="org-left">32 bits</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">single-precision floating-point</td>
<td class="org-left">6 significant digits</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-left">double-precision floating-point</td>
<td class="org-left">10 significant digits</td>
</tr>

<tr>
<td class="org-left">long double</td>
<td class="org-left">extended-precision floating-point</td>
<td class="org-left">10 significant digits</td>
</tr>
</tbody>
</table>


<p>
The standard guarantees a minimum size for each of the arithmetic types, but it does not prevent
compilers from using larger sizes. Indeed, almost all compilers use a larger size for int than
is strictly required.
</p>

<p>
In C++ it is perfectly <b>legal</b> to assign a <b><b>negative number</b></b> to an object with <b><b>unsigned type</b></b>.
</p>
</div>

<div id="outline-container-org31557db" class="outline-3">
<h3 id="org31557db"><span class="section-number-3">2.1</span> Literals</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-orgb715d7e" class="outline-4">
<h4 id="orgb715d7e"><span class="section-number-4">2.1.1</span> for Integer Literals:</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Three Notations:
</p>
<ul class="org-ul">
<li>20   // decimal</li>
<li>020  // octal</li>
<li>0x14 // hexadecimal</li>
</ul>

<p>
By adding a suffix, we can force the type of a literal integer constant to be type long or
unsigned or unsigned long:
</p>

<ul class="org-ul">
<li>128u   // unsigned</li>
<li>1L     // long</li>
<li>128UL  // unsigned long</li>
<li>8Lu    // unsigned long</li>
</ul>

<p>
When specifying a long, use the uppercase L: the lowercase letter 'l' is too easily mistaken for
the digit '1'.
</p>
</div>
</div>

<div id="outline-container-org035cdb3" class="outline-4">
<h4 id="org035cdb3"><span class="section-number-4">2.1.2</span> For Floating-point Literals</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
3.12149F , .001f , 12.3L , 0. , 1e-3f, 0e0
</p>
</div>
</div>

<div id="outline-container-orga12b70f" class="outline-4">
<h4 id="orga12b70f"><span class="section-number-4">2.1.3</span> Boolean</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
<b><b>true</b></b> , <b><b>false</b></b> :  bool test = flase;
</p>
</div>
</div>

<div id="outline-container-orgf1ed7b3" class="outline-4">
<h4 id="orgf1ed7b3"><span class="section-number-4">2.1.4</span> Character Literals</h4>
<div class="outline-text-4" id="text-2-1-4">
<ul class="org-ul">
<li>char:  'a' , '2', ' '</li>
<li>wchar<sub>t</sub>:  L'a'</li>
</ul>
</div>
</div>

<div id="outline-container-orge6733de" class="outline-4">
<h4 id="orge6733de"><span class="section-number-4">2.1.5</span> Character String Literals</h4>
<div class="outline-text-4" id="text-2-1-5">
<p>
String literals are arrays of constant characters.  Every string literal ends with a <b><b>null</b></b>
character added by the compiler.
</p>
<ul class="org-ul">
<li>"hallo"    // character string literal</li>
<li>L"hallo"   // wide string literal</li>
</ul>

<p>
Putting a backslash as the last character on a line causes that line and the next to be treated
as a single line. Eg.:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">cou</span>\
<span style="color: #7fffd4; font-weight: bold;">t</span> &lt;&lt; <span style="color: #ffa07a;">"Hi"</span> &lt;&lt; st\
<span style="color: #7fffd4;">d</span>::endl;

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">is equivalent to</span>
<span style="color: #7fffd4;">std</span>::cout &lt;&lt; <span style="color: #ffa07a;">"Hi"</span> &lt;&lt; <span style="color: #7fffd4;">std</span>::endl;
</pre>
</div>
</div>
</div>

<div id="outline-container-org813daff" class="outline-4">
<h4 id="org813daff"><span class="section-number-4">2.1.6</span> Variable</h4>
<div class="outline-text-4" id="text-2-1-6">
<p>
C++ programmers tend to refer to variables as "variables" or as "objects" interchangeably.
</p>

<p>
Initialization:
</p>
<ul class="org-ul">
<li>direct-initialization: int ival(1024);</li>
<li>copy-initialization:   int ival = 1024;</li>
</ul>

<p>
The direct syntax is more flexible and can be slightly more efficient.
</p>
</div>

<div id="outline-container-org36cfd49" class="outline-5">
<h5 id="org36cfd49"><span class="section-number-5">2.1.6.1</span> Variable Initialization Rules</h5>
<div class="outline-text-5" id="text-2-1-6-1">
<p>
When we define a variable without an initializer, the system <b><b>sometimes</b></b> initializes the variable
for us. What value, if any, is supplied depends on the type of the variable and may depend on
where it is defined.
</p>

<ul class="org-ul">
<li>variable of built-in type
<ul class="org-ul">
<li>defined outside any function body:      initialized to zero</li>
<li>defined inside the body of a function:  uninitialized</li>
</ul></li>
<li>Variables of Class Type
<ul class="org-ul">
<li>When a variable of Class type is defined but an initializer is not provided, then the
<b><b>default constructor</b></b> will be used.</li>
<li>Some class types do not have a default constructor. For these types, every definition
<b><b>must</b></b> provide explicit initializer(s).</li>
</ul></li>
</ul>

<p>
Note:
</p>

<p>
We recommend that <b><b>every object of build-in type</b></b> be initialized.
</p>

<p>
Compiler is not required to detect a use of an uninitialized variable, although many will warn
about at least some uses of uninitialized variables. However, <b><b>no</b></b> compiler can detect <b><b>all</b></b> uses of
uninitialized variables.
</p>

<p>
The problem is that <b><b>uninitialized variables</b></b> actually <b><b>do have a value</b></b>. The compiler puts the
variable somewhere in memory and treats whatever bit pattern was in that memory as the
variable's initial state.
</p>
</div>
</div>

<div id="outline-container-org7d9515a" class="outline-5">
<h5 id="org7d9515a"><span class="section-number-5">2.1.6.2</span> Declarations and Definitions</h5>
<div class="outline-text-5" id="text-2-1-6-2">
<p>
A <b><b>Definition</b></b> of a variable allocates storage for the variable and may also specify an initial
value for the variable.
</p>

<p>
A <b><b>declaration</b></b> makes known the type and name of the variable to the program. A definition is also
a declaration. When we define a variable, we declare its name and type. We can declare a name
without defining it by using the <b><b>extern</b></b> keyword.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">extern</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span>;    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">declare but does not define i</span>
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span>;           <span style="color: #add8e6;">// </span><span style="color: #add8e6;">declares and defines i</span>
</pre>
</div>

<p>
A extern declaration <b><b>does not allocate storage</b></b>. In effect, it claims that a definition of the
variable exists elsewhere in the program. A variable can be declared multiple times in a
program, but it must be defined only once.
</p>

<p>
The initializer must have storage to initialize, and only a definition allocates storage. So if
an initializer is present, the declaration is treated as a definition even if the declaration is
labeled extern:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">extern</span> <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">pi</span> = 3.14;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">definition</span>
</pre>
</div>

<p>
An extern declaration may include an initializer only if it appears <b><b>outside a function</b></b>.
</p>
</div>
</div>
</div>

<div id="outline-container-org06bbab8" class="outline-4">
<h4 id="org06bbab8"><span class="section-number-4">2.1.7</span> Const Qualifier</h4>
<div class="outline-text-4" id="text-2-1-7">
<p>
We cannot subsequently change the value of an object declared to be const, so we must
initialize it when it is define:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">bufSize</span> = 512;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">unmodifiable</span>
<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span>, <span style="color: #7fffd4; font-weight: bold;">j</span> = 0;        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: i is uninitialized const</span>
</pre>
</div>

<p>
Nonconst variables are extern by default. To make a const variable accessible to other files we
<b>must explicitly</b> specify that it is extern.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">file_1.cc</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">defines and initializes a const that is accessible to other files</span>
<span style="color: #fa8072;">extern</span> <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">bufSize</span> = fcn();
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">file_2.cc</span>
<span style="color: #fa8072;">extern</span> <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">bufSize</span>;
<span style="color: #fa8072;">for</span> (<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">index</span> = 0; index != bufSize; ++index)
  <span style="color: #add8e6;">//</span><span style="color: #add8e6;">...</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7e0f702" class="outline-3">
<h3 id="org7e0f702"><span class="section-number-3">2.2</span> References</h3>
<div class="outline-text-3" id="text-2-2">
<p>
A reference serves as an alternative name for an object. It is defined by preceding a variable
name by the <b>&amp;</b> symbol. A reference <b>must</b> be initialized using an object of the <b><b>same type</b></b> as the
reference:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ival</span> = 1024;
<span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">refVal</span> = ival;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: refVal refers to ival</span>
<span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">refVal2</span>;         <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: a reference must be initialized</span>
<span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">refVal3</span> = 10;    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: initializer must be an object.</span>
</pre>
</div>

<p>
When a reference is initialized, it remains bound to that object as long as the reference
exists. There is no way to rebind a reference to a different object.
</p>

<p>
The important concept to understand is that a reference is just another name for an object. So
<b><b>all operations</b></b> on a reference are <b>actually</b> operations <b><b>on the underlying object</b></b> to which the
reference is bound.
</p>

<div class="org-src-container">
<pre class="src src-c++">refVal += 2;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">equal to: ival += 2</span>
</pre>
</div>
</div>

<div id="outline-container-org3043bb7" class="outline-4">
<h4 id="org3043bb7"><span class="section-number-4">2.2.1</span> const References</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
A const reference is a reference that may refer to a const object, and it can be initialized to
an object of a different type or to an rvalue.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ival</span> = 1024;
<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">refVal</span> = ival;
<span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">ref2</span> = ival;               <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: nonconst reference to a const object.</span>
<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">r</span> = 1024;            <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok:    **legal for const references only**</span>
</pre>
</div>

<p>
This behavior is easiest to understand when we look at what happens when we bind a reference to
an object of a different type. If we write
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">dval</span> = 3.14;
<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">ri</span> = dval;
</pre>
</div>

<p>
the compiler transforms this code into something like this:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">temp</span> = dval;         <span style="color: #add8e6;">// </span><span style="color: #add8e6;">create temporary int from the double</span>
<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">ri</span> = temp;    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">bind ri to that temporary</span>
</pre>
</div>

<p>
If ri were not const, then we could assign a new value to ri. Doing so would not change dval but
would instead change temp. To the programmer expecting that assignments to ri would change dval,
it would appear that the change did not work. Allowing only const references to be bound to
values requiring temporaries avoids the problem entirely because a const reference is read-only.
</p>

<p>
Note: A nonconst reference may be attached only to an object of the same type as the reference
itself.
</p>
</div>
</div>
</div>

<div id="outline-container-org0069365" class="outline-3">
<h3 id="org0069365"><span class="section-number-3">2.3</span> Typedef Names</h3>
<div class="outline-text-3" id="text-2-3">
<p>
A typedef lets us define a synonym for a type, eg.:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">typedef</span> <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #9acd32; font-weight: bold;">wages</span>;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">wages is a synonym for double</span>
<span style="color: #9acd32; font-weight: bold;">wages</span> <span style="color: #7fffd4; font-weight: bold;">hourly</span>, <span style="color: #7fffd4; font-weight: bold;">weekly</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org7845a9b" class="outline-3">
<h3 id="org7845a9b"><span class="section-number-3">2.4</span> Enumerations</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The rules are equal to that in C, so I do not want to repeat it here.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">input is 0, output is 1, and append is 2</span>
<span style="color: #fa8072;">enum</span> <span style="color: #9acd32; font-weight: bold;">open_modes</span> {<span style="color: #7fffd4; font-weight: bold;">input</span>, <span style="color: #7fffd4; font-weight: bold;">output</span>, <span style="color: #7fffd4; font-weight: bold;">append</span>};

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">An enumerator value need not be unique.</span>
<span style="color: #fa8072;">enum</span> <span style="color: #9acd32; font-weight: bold;">points</span> {<span style="color: #7fffd4; font-weight: bold;">point2d</span> = 2, <span style="color: #7fffd4; font-weight: bold;">point2w</span>, <span style="color: #7fffd4; font-weight: bold;">point3d</span> = 3, <span style="color: #7fffd4; font-weight: bold;">point3w</span> };
</pre>
</div>

<p>
An object of enumeration type may be initialized or assigned only by one of its enumerators or
by another object of the same enumeration type:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">points</span> <span style="color: #7fffd4; font-weight: bold;">pt3d</span> = point3d;        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok</span>
<span style="color: #9acd32; font-weight: bold;">points</span> <span style="color: #7fffd4; font-weight: bold;">pt2w</span> = 3;              <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: pt2w initialized with int</span>
pt2w = pt3d ;                 <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd01fa92" class="outline-3">
<h3 id="orgd01fa92"><span class="section-number-3">2.5</span> Class Types</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Each class defines an <b><b>interface</b></b> and <b><b>implementation</b></b>. The interface consists of the operations
that we expect code that uses the class to execute. The implementation typically includes the
data needed by the class. The implementation also includes any functions needed to define the
class but that are not intended for general use.
</p>
</div>

<div id="outline-container-org6f86fc4" class="outline-4">
<h4 id="org6f86fc4"><span class="section-number-4">2.5.1</span> Define a Class</h4>
<div class="outline-text-4" id="text-2-5-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">operations on Sales_item objects will go here</span>
<span style="color: #fa8072;">private</span>:
  <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">isbn</span>;
  <span style="color: #9acd32; font-weight: bold;">unsigned</span> <span style="color: #7fffd4; font-weight: bold;">units_sold</span>;
};
</pre>
</div>

<p>
Note: It is a common mistake among new programmers to forget the <b>semicolon</b> at the <b><b>end of a class</b></b>
<b><b>definition</b></b>.
</p>
</div>

<div id="outline-container-org3b2a4a2" class="outline-5">
<h5 id="org3b2a4a2"><span class="section-number-5">2.5.1.1</span> Members</h5>
<div class="outline-text-5" id="text-2-5-1-1">
<p>
The operations and data that are part of class are referred to as its members. The operations
are referred to as the <b><b>member function</b></b> and the data as <b><b>data members</b></b>.
</p>

<p>
There is one crucially important difference between how we define variables and class data
members: We ordinarily can <b><b>not define</b></b> the data members, we can only <b><b>name them</b></b> and say what <b><b>types</b></b>
they have. Classes control initialization through special member functions called constructors.
</p>
</div>
</div>

<div id="outline-container-orgcaee990" class="outline-5">
<h5 id="orgcaee990"><span class="section-number-5">2.5.1.2</span> Access Labels</h5>
<div class="outline-text-5" id="text-2-5-1-2">
<p>
The class may contain zero or more <b><b>public</b></b> or <b><b>private</b></b> access labels.
</p>

<p>
The access labels, public and private, may appear multiple times in a class definition. A given
label applies until the next access label is seen.
</p>

<p>
Code that uses the class may access only the public members. Ordinarily we put the operations in
the public section so that any code in the program may execute these operations.
</p>

<p>
Code that is not part of the class does not have access to the private members. By making the
Sales<sub>item</sub> data members private, <b><b>objects</b></b> of type Sales<sub>item</sub> <b><b>may execute the operations</b></b> but <b><b>not</b></b>
<b><b>change the data directly</b></b>.
</p>
</div>
</div>

<div id="outline-container-orgf19f000" class="outline-5">
<h5 id="orgf19f000"><span class="section-number-5">2.5.1.3</span> Using the struct Keyword</h5>
<div class="outline-text-5" id="text-2-5-1-3">
<p>
C++ supports a second key word, <b><b>struct</b></b>, that can be used to define class types. The struct
keyword is inherited from C.
</p>

<p>
If we define a class using the <b><b>class</b></b> keyword, then any members defined <b><b>before the first access</b></b>
<b><b>label</b></b> are <b><b>implicitly</b></b> <b><b>private</b></b>; if we use the <b><b>struct</b></b> keyword, then those members are <b><b>public</b></b>. This
is the single difference between keyword class and struct.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org69fd322" class="outline-3">
<h3 id="org69fd322"><span class="section-number-3">2.6</span> Header Files</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Proper use of header files can provide two benefits: all files are guaranteed to use the same
declaration for given entity; and should a declaration require change, only the header needs to
be updated.
</p>
</div>

<div id="outline-container-orgeed35e3" class="outline-4">
<h4 id="orgeed35e3"><span class="section-number-4">2.6.1</span> Headers Are for Declarations, Not Definitions</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
Definitions may only occur once, and declarations may occur multiple times. Because headers are
included in multiple source files, they should not contain definitions of variables or
functions.
</p>

<p>
There are three exceptions to the rule that headers should not contain definitions: class, const
objects whose value is known at compile time, and inline functions are all defined in
headers. These entities may be defined in more than one source file as long as the definitions
in each file are exactly the same. These entities are defined in headers because the compiler
needs their definitions to generate code.
</p>
</div>
</div>

<div id="outline-container-org0775b13" class="outline-4">
<h4 id="org0775b13"><span class="section-number-4">2.6.2</span> Avoiding Multiple Inclusions</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
A preprocessor variable has two states: defined or not yet defined.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072; font-weight: bold;">#if</span><span style="color: #fa8072; font-weight: bold;">n</span><span style="color: #fa8072; font-weight: bold;">def</span> SALESITEM_H
<span style="color: #fa8072; font-weight: bold;">#define</span> <span style="color: #7fffd4; font-weight: bold;">SALESITEM_H</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">Definition of Sales_item class and related functions goes here</span>
<span style="color: #fa8072; font-weight: bold;">#endif</span>
</pre>
</div>

<p>
Headers should have guards, even if they are not included by another header.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org2733261" class="outline-2">
<h2 id="org2733261"><span class="section-number-2">3</span> Library Types</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org4587ff1" class="outline-3">
<h3 id="org4587ff1"><span class="section-number-3">3.1</span> using declaration</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A <b><b>using declaration</b></b> allows us to access a name from a namespace without the prefix
<b><b>namespace<sub>name</sub>::</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">a separate using declaration is required for each name</span>
<span style="color: #fa8072;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">cin</span>;
<span style="color: #fa8072;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">string</span>;

<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">main</span>() {
  <span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">s</span>;
  cin &gt;&gt; s;
  cout &lt;&lt; s;      <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: no using declaration for std::cout</span>
  <span style="color: #7fffd4;">std</span>::cout &lt;&lt; s;
}
</pre>
</div>

<p>
There is one case in which we should <b><b>always</b></b> use the fully qualified library names: <b><b>inside</b></b> <b><b>header</b></b>
<b><b>files</b></b>. The reason is that the contents of a header are copied into our program text by the
preprocessor. If we place a using declaration within a header, it is equivalent to placing the
same using declaration in every program that includes the header whether that wants the using
declaration or not.
</p>
</div>
</div>

<div id="outline-container-orga72c741" class="outline-3">
<h3 id="orga72c741"><span class="section-number-3">3.2</span> Library STRING Type</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-orgab5fb2b" class="outline-4">
<h4 id="orgab5fb2b"><span class="section-number-4">3.2.1</span> Defining and Initializing strings</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">&lt;string&gt;</span>
<span style="color: #fa8072;">using</span> <span style="color: #9acd32; font-weight: bold;">std</span>:string;

<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">s1</span>;          <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Default constructor; s1 is the empty string</span>
<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">s2</span>(s1);      <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Initialize s2 as a copy of s1</span>
<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">s3</span>(<span style="color: #ffa07a;">"value"</span>); <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Initialize s3 as a copy of the string literal</span>
<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">s4</span>(n, <span style="color: #ffa07a;">'c'</span>);  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Initialize s4 with n copies of the character 'c'</span>
</pre>
</div>

<p>
<b>Caution</b>: For historical reasons, and for compatibility with C, character <b><b>string literals</b></b> are <b>not</b>
<b><b>the same type</b></b> as the standard <b><b>library</b></b> <b><b>string type</b></b>.
</p>
</div>
</div>

<div id="outline-container-org819b34a" class="outline-4">
<h4 id="org819b34a"><span class="section-number-4">3.2.2</span> Reading and Writing strings</h4>
<div class="outline-text-4" id="text-3-2-2">
</div>
<div id="outline-container-org6732198" class="outline-5">
<h5 id="org6732198"><span class="section-number-5">3.2.2.1</span> input operate</h5>
<div class="outline-text-5" id="text-3-2-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">s</span>;
cin &gt;&gt; s;
cout &lt;&lt; s &lt; endl;
</pre>
</div>

<p>
The string input operator '&gt;&gt;' (e.g., cin &gt;&gt; a<sub>string</sub>):
</p>
<ul class="org-ul">
<li>Reads and discards any leading whitespace (e.g., spaces, newlines, tabs)</li>
<li>It then <b><b>reads</b></b> characters <b><b>until the next whitespace character</b></b> is encountered</li>
</ul>

<p>
So, if the input to this program is "   Hallo World!  ", then the output will be "Hello" with no
extra spaces.
</p>
</div>
</div>

<div id="outline-container-org68b7f3c" class="outline-5">
<h5 id="org68b7f3c"><span class="section-number-5">3.2.2.2</span> getline</h5>
<div class="outline-text-5" id="text-3-2-2-2">
<p>
This is a function that takes both an input stream and a string. It reads the <b><b>next line</b></b> of input
from the stream and stores what it read, <b><b>not including the newline</b></b>, in its string
arguments. Unlike the input operator, getline does not ignore leading newlines. Whenever getline
encounters a newline, even if it is the first character in the input, it stops reading the input
and returns.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe11cf4" class="outline-4">
<h4 id="orgbe11cf4"><span class="section-number-4">3.2.3</span> Operations on strings</h4>
<div class="outline-text-4" id="text-3-2-3">
<div class="org-src-container">
<pre class="src src-c++">s.empty()
s.size()          <span style="color: #add8e6;">// </span><span style="color: #add8e6;">number of characters in s</span>
s[n]              <span style="color: #add8e6;">// </span><span style="color: #add8e6;">n-th character in s; positions starts at 0</span>
s1 + s2           <span style="color: #add8e6;">// </span><span style="color: #add8e6;">concatenation of s1 and s2</span>
s1 = s2           <span style="color: #add8e6;">// </span><span style="color: #add8e6;">replaces characters in s1 by a copy of s2</span>
  s1 == s2
  !=, &lt;, &gt;, &lt;=, &gt;=  <span style="color: #add8e6;">//</span><span style="color: #add8e6;">using the same strategy as in a dictionary</span>
</pre>
</div>

<p>
When mixing strings and string literals, at least one operand to each <b><b>+</b></b> operator must be of
string type.
</p>
</div>
</div>

<div id="outline-container-orgf688218" class="outline-4">
<h4 id="orgf688218"><span class="section-number-4">3.2.4</span> string::size<sub>type</sub></h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
The <b><b>size</b></b> operation returns a value of type <b><b>string::size<sub>type</sub></b></b> instead of an int. The string
class&#x2013;and many other library types&#x2013;defines several <b><b>companion types</b></b>. These companion types make
it possible to <b><b>use the library types in a</b></b> <b>machine-independent</b> <b><b>manner</b></b>. The type size<sub>type</sub> is
defined as a synonym for an <b><b>unsigned type</b></b> &#x2013; either unsigned int or unsigned long &#x2013; that is
<b><b>guaranteed to be big enough</b></b> to hold the size of any string.
</p>

<p>
the size of int or unsigned int <b><b>on some machines</b></b> is <b><b>too small</b></b> to hold the size of even plausibly
large strings. For example, if a machines has 16-bit ints, then the largest string an int could
represent would have 32,767 characters.
</p>
</div>
</div>

<div id="outline-container-org6f085d5" class="outline-4">
<h4 id="org6f085d5"><span class="section-number-4">3.2.5</span> fetching a character from a string</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
Subscript can be used on either side of an assignment:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">str</span>(<span style="color: #ffa07a;">"some string"</span>);
<span style="color: #fa8072;">for</span> (<span style="color: #7fffd4;">string</span>::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">ix</span> = 0; ix != str.size(), ++ix) {
  count &lt;&lt; str[ix] &lt;&lt; endl;
  str[ix] = <span style="color: #ffa07a;">'*'</span>;
 }
</pre>
</div>

<p>
Unlike in Python, in C++ the subscript can not be less than zero, and should also be less than the size
of the string.
</p>
</div>
</div>

<div id="outline-container-orgf5c5aea" class="outline-4">
<h4 id="orgf5c5aea"><span class="section-number-4">3.2.6</span> dealing with the Characters of a string</h4>
<div class="outline-text-4" id="text-3-2-6">
<p>
These functions are defined in the cctype header:
</p>
<div class="org-src-container">
<pre class="src src-c++">isalnum(c);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">true if c is a letter or a digit</span>
isalpha(c);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">true if c is a letter</span>
iscntrl(c);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">true if c is a control character</span>
isdigit(c);
isgraph(c);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">true if c not a space but is printable</span>
islower(c);
isprint(c);
ispunct(c);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">true if c is a punctuation character</span>
isspace(c);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">true if c is whitespace</span>
isupper(c);
tolower(c);
toupper(c);
</pre>
</div>

<p>
<b><b>Advice</b></b>: Use the C++ versions of C library headers
</p>

<p>
The standard C headers names use the form <b><b>name.h</b></b>. The C++ versions of these headers are named
<b><b>cname</b></b> &#x2013; <b><b>remove</b></b> the <b><b>.h</b></b> suffix and precede the name by the letter <b><b>c</b></b>. The <b><b>c</b></b> indicates that the
header originally comes from the C library. Hence, cctype has the same contents as ctype.h. In
particular, the names defined in the cname headers are defined inside the std namespace,
whereas those defined in the .h versions are not.
</p>
</div>
</div>
</div>

<div id="outline-container-org2c56add" class="outline-3">
<h3 id="org2c56add"><span class="section-number-3">3.3</span> Library vector Type</h3>
<div class="outline-text-3" id="text-3-3">
<p>
A vector is a class template. Templates let us write a single class or function definition that
can be used on a variety of types. To declare objects of a type generated from a class template,
we must supply additional information. In the case of vector, we must say <b><b>what type of objects</b></b>
the vector will contain.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">&lt;vector&gt;</span>
<span style="color: #fa8072;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">vector</span>;

<span style="color: #9acd32; font-weight: bold;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt; <span style="color: #7fffd4; font-weight: bold;">ivec</span>;
<span style="color: #9acd32; font-weight: bold;">vector</span>&lt;Sales_item&gt; <span style="color: #7fffd4; font-weight: bold;">sales_vex</span>;
</pre>
</div>

<p>
<b><b>Vector is not a type</b></b>. It is a template that we can use to define any number of types. Each of
vector type specifies an element type. Hence, vector&lt;int&gt; and vector&lt;string&gt; are types.
</p>
</div>

<div id="outline-container-org5375fb4" class="outline-4">
<h4 id="org5375fb4"><span class="section-number-4">3.3.1</span> Defining and Initializing vectors</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">vector</span>&lt;T&gt; <span style="color: #7fffd4; font-weight: bold;">v1</span>;       <span style="color: #add8e6;">// </span><span style="color: #add8e6;">vector that holds objects of type T;</span>
<span style="color: #9acd32; font-weight: bold;">vector</span>&lt;T&gt; <span style="color: #7fffd4; font-weight: bold;">v2</span>(v1);
<span style="color: #9acd32; font-weight: bold;">vector</span>&lt;T&gt; <span style="color: #7fffd4; font-weight: bold;">v3</span>(n, i); <span style="color: #add8e6;">// </span><span style="color: #add8e6;">v3 has n elements with value i</span>
<span style="color: #9acd32; font-weight: bold;">vector</span>&lt;T&gt; <span style="color: #7fffd4; font-weight: bold;">v2</span>(n);    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">v4 has n copies of a value-initialized object</span>
</pre>
</div>

<p>
Key Concept: <b>Vectors Grow Dynamically</b>
</p>

<p>
A central property of vectors is that they are required to be implemented so that it is
efficient to add elements to them at run time. Although we can preallocate a given number of
elements in a vector, it is usually more <b><b>efficient to define an empty vector and add elements</b></b> to
it.
</p>
</div>
</div>

<div id="outline-container-orgc177448" class="outline-4">
<h4 id="orgc177448"><span class="section-number-4">3.3.2</span> Operations on vectors</h4>
<div class="outline-text-4" id="text-3-3-2">
<div class="org-src-container">
<pre class="src src-c++">v.empty()
v.size()          <span style="color: #add8e6;">// </span><span style="color: #add8e6;">number of elements in v</span>
v.push_back(t)    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Adds element with value t to end of v</span>
v[n]
v1 = v2
  v1 == v2
  !=, &lt;, &gt;, &lt;=, &gt;=
</pre>
</div>

<p>
The size member returns a value of the size<sub>type</sub> defined by the corresponding vector type. To
use size<sub>type</sub>, we must name the type in which it is defined. A vector type always includes the
elements type of the vector:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">size_type</span>       <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok</span>
<span style="color: #7fffd4;">vector</span>::<span style="color: #7fffd4; font-weight: bold;">size_type</span>            <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8000db5" class="outline-4">
<h4 id="org8000db5"><span class="section-number-4">3.3.3</span> Subscripting a vector</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
Objects in the vector are not named, and they can be accessed by their position in the vector.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">reset the elements in the vector to zero</span>
<span style="color: #fa8072;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">ix</span> = 0; ix != ivec.size(); ++ix)
  ivec[ix] = 0;

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">here: ix == ivec.size()</span>
ivec[ix] = ix;    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">disaster: subscripting does not add elements</span>
</pre>
</div>

<p>
一定要注意: subscript 只能修改已经存在的 Elements. 而 push<sub>back</sub> 才能增加新的 Elements. 这个和 C
不同.
</p>

<p>
<b>Key Concept</b>: Safe, Generic Programming
</p>

<p>
Programmers coming to C++ from C might be surprised that our loop used != rather than &lt; to test
the index against the size of the vector, and we call the size member in the for rather than
calling it once before the loop and remembering its value.
</p>

<p>
C++ Programmers tend to write loops using != in preference to &lt; as a matter of habit. In this
case, there is no particular reason to choose one operator or the other.
</p>

<p>
Calling size rather than remembering its value is similarly unnecessary in this case but again
reflects a good habit. <b><b>In C++, data structures such as vector can grow dynamically</b></b>. If the loop
did add elements, then testing a saved value of size would fail &#x2013; our loop would not account
for the newly added elements.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb7480e6" class="outline-3">
<h3 id="orgb7480e6"><span class="section-number-3">3.4</span> Iterators</h3>
<div class="outline-text-3" id="text-3-4">
<p>
An iterator is a type that <b><b>lets us examine the elements in a container</b></b> and <b><b>navigate from one</b></b>
<b><b>element to another</b></b>. Iterators are more general than subscripts: <b>All</b> of the library <b><b>containers</b></b>
<b><b>define iterator types</b></b>, but <b><b>only a few</b></b> of them <b><b>support subscripting</b></b>.
</p>
</div>

<div id="outline-container-org3c1c1a8" class="outline-4">
<h4 id="org3c1c1a8"><span class="section-number-4">3.4.1</span> Container iterator Type</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Each of the container types, such as vector, defines its own iterator type:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">iterator</span> <span style="color: #7fffd4; font-weight: bold;">iter</span>;
</pre>
</div>

<p>
This statement defines a variable named iter, whose type is the type named iterator defined by
vector&lt;int&gt;.
</p>

<p>
<b><b>Terminology</b></b>: Iterators and Iterator Types
</p>

<p>
Iterator is used to refer to two things. We speak generally of the concept of an iterator, and
we speak specifically of a concrete iterator type defined by a container, such as vector&lt;int&gt;.
</p>

<p>
<b><b>Each container class defines its own iterator type</b></b> that can be used to access the elements in
the container. That is, each container defines a type named iterator, and that type supports the
actions of an (conceptual) iterator.
</p>
</div>

<div id="outline-container-org32ccecf" class="outline-5">
<h5 id="org32ccecf"><span class="section-number-5">3.4.1.1</span> The begin and end Operations</h5>
<div class="outline-text-5" id="text-3-4-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">iterator</span> <span style="color: #7fffd4; font-weight: bold;">iter</span> = ivec.begin();
</pre>
</div>

<p>
Each container defines <b><b>begin</b></b> and <b><b>end</b></b> that return iterators. The iterator returned by <b><b>begin</b></b>
refers to the <b><b>first</b></b> <b><b>element</b></b>, if any, in the container. And the iterator returned by <b><b>end</b></b> is an
iterator positioned "<b>one past the end</b>" of the vector, which refers to a nonexistent element "off
the end" of the vector. If the vector is <b><b>empty</b></b>, the iterator returned by begin is the same as
the iterator returned by end.
</p>
</div>
</div>

<div id="outline-container-org73deb97" class="outline-5">
<h5 id="org73deb97"><span class="section-number-5">3.4.1.2</span> Using Iterators</h5>
<div class="outline-text-5" id="text-3-4-1-2">
<p>
Iterator types use the dereference operator '*' to access the element to which the iterator
refers.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">using subscripting</span>
<span style="color: #fa8072;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">ix</span> = 0; ix!= ivec.size(); ++ix)
  ivec[ix] = 0;

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">using iterators</span>
<span style="color: #fa8072;">for</span> ( <span style="color: #7fffd4;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">iterator</span> <span style="color: #7fffd4; font-weight: bold;">iter</span> = ivec.begin(); iter !=ivec.end(); ++iter)
  *iter = 0;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb8f1d51" class="outline-5">
<h5 id="orgb8f1d51"><span class="section-number-5">3.4.1.3</span> Supported Operations</h5>
<div class="outline-text-5" id="text-3-4-1-3">
<p>
Iterators use the increment operator ( <b><b>++</b></b> ) to advance an iterator to the next element in the
container.
</p>

<p>
Two iterators can be compared using either <b><b>==</b></b> or <b><b>!=</b></b>.
</p>

<p>
In addition to ++, vector iterators ( but <b><b>few of the other library container iterators</b></b>) also
support other arithmetic operations:
</p>

<ol class="org-ol">
<li><b><b>iter1 - iter2</b></b>:</li>
</ol>

<p>
The operation returns a value of a signed integral type named <b><b>difference<sub>type</sub></b></b>, which, like
size<sub>type</sub>, is defined by vector. Both iter1 and iter2 must refer to elements in the same vector
or the element one past the end of that vector.
</p>

<ol class="org-ol">
<li><b><b>iter + n</b></b>  / <b><b>iter - n</b></b>:</li>
</ol>

<p>
Doing so yields a new iterator position n elements ahead of or behind the element to which iter
refers. The result of the addition or subtraction must refer to an element in the vector to
which iter refers or to one past the end of that vector. The type of the value added or
subtracted ought ordinarily to be the vector's size<sub>type</sub> or difference<sub>type</sub>.
</p>

<p>
<b>Beware</b>: Any operation that changes the size of a vector makes existing iterators invalid. For
example, after calling push<sub>back</sub>, you should not rely on the value of an iterator into the
vector.
</p>

<p>
测试后发现, 使用 push<sub>back</sub> 增加一个元素以后, 旧的元素依然可以浏览, 但是新的元素必须使用 begin()或
者 end() 重新索引以后才能被访问, 否则在原来最后一个元素后使用 *(iter++) 指向的并非是新添加的元素.
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org122b0bf" class="outline-2">
<h2 id="org122b0bf"><span class="section-number-2">4</span> Expressions</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org224d5f2" class="outline-3">
<h3 id="org224d5f2"><span class="section-number-3">4.1</span> The sizeof Operator</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The <b><b>sizeof</b></b> operator returns a value of type <b><b>size<sub>t</sub></b></b> that is the size, <b>in bytes</b>, of an object or
type name. The sizeof operator takes one of the following forms:
</p>
<ul class="org-ul">
<li>sizeof (type name);</li>
<li>sizeof (expr);</li>
<li>sizeof expr;</li>
</ul>

<p>
Because sizeof returns the size of a entire array, we can determine the number of elements by
dividing the sizeof the array by the sizeof an element:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">sizeof(ia) / sizeof(*ia) returns the number of elements in ia</span>
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">sz</span> = <span style="color: #fa8072;">sizeof</span>(ia) / <span style="color: #fa8072;">sizeof</span> (*ia);
</pre>
</div>
</div>
</div>

<div id="outline-container-org51d9b09" class="outline-3">
<h3 id="org51d9b09"><span class="section-number-3">4.2</span> The new and delete Expressions</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org6d02e8f" class="outline-4">
<h4 id="org6d02e8f"><span class="section-number-4">4.2.1</span> Initializing Dynamically Allocated Objects</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
<b><b>Dynamically allocated objects</b></b> may be initialized, in much the same way as we initialize
variables.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">pi</span> = <span style="color: #fa8072;">new</span> <span style="color: #9acd32; font-weight: bold;">int</span>;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">pi points to dynamically allocated, unnamed, uninitialized int</span>

<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span>(1024);             <span style="color: #add8e6;">// </span><span style="color: #add8e6;">value of i is 1024</span>
<span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">pi</span> = <span style="color: #fa8072;">new</span> <span style="color: #9acd32; font-weight: bold;">int</span>(1024); <span style="color: #add8e6;">// </span><span style="color: #add8e6;">object to which pi points is 1024</span>

<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">s</span>(10, <span style="color: #ffa07a;">'9'</span>);
<span style="color: #9acd32; font-weight: bold;">string</span> *<span style="color: #7fffd4; font-weight: bold;">ps</span> = <span style="color: #fa8072;">new</span> <span style="color: #9acd32; font-weight: bold;">string</span>(10, <span style="color: #ffa07a;">'9'</span>);
</pre>
</div>

<p>
If we do not explicitly state an initializer, then a dynamically allocated object is initialized
in the same way as is a variable that is defined inside a function. If the object is of class
type, it is initialized using the default constructor for the type; if it is of built-in type,
it is uninitialized. <b><b>But it is (almost) always a good idea to initialize dynamically allocated</b></b>
<b><b>objects</b></b>.
</p>

<p>
We can also value-initialize a dynamically allocated object:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">string</span> *<span style="color: #7fffd4; font-weight: bold;">ps</span> = <span style="color: #fa8072;">new</span> <span style="color: #9acd32; font-weight: bold;">string</span>();    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">initialized to empty string</span>
<span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">pi</span> = <span style="color: #fa8072;">new</span> <span style="color: #9acd32; font-weight: bold;">int</span>();          <span style="color: #add8e6;">// </span><span style="color: #add8e6;">pi points to an int value-initialized to 0</span>
<span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">pi</span> = <span style="color: #fa8072;">new</span> <span style="color: #9acd32; font-weight: bold;">int</span>;            <span style="color: #add8e6;">// </span><span style="color: #add8e6;">pi points to an uninitialized int</span>
</pre>
</div>

<p>
<b><b>Memory Exhaustion</b></b>:
</p>

<p>
If a new expression cannot acquire the requested memory, it throws an exception named <b><b>bad<sub>alloc</sub></b></b>.
</p>
</div>
</div>

<div id="outline-container-org61cfccd" class="outline-4">
<h4 id="org61cfccd"><span class="section-number-4">4.2.2</span> Destroying Dynamically Allocated Objects</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
After the using of the object, we must <b><b>explicitly</b></b> return the object's memory to the free store.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">delete</span> pi;
</pre>
</div>
<p>
frees the memory associated with the int object addressed by pi.
</p>

<p>
It is <b><b>illegal</b></b> to apply <b><b>delete</b></b> to a <b><b>pointer</b></b> that addresses memory that was <b><b>not allocated by new</b></b>.
</p>

<p>
It is legal to delete a pointer whose value is zero:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">ip</span> = 0
  <span style="color: #fa8072;">delete</span> ip;    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">OK: always ok to delete a pointer that is equal to 0</span>
</pre>
</div>

<p>
The language <b><b>guarantees</b></b> that <b><b>deleting a pointer that is equal to zero is safe</b></b>.
</p>
</div>

<div id="outline-container-org00e128f" class="outline-5">
<h5 id="org00e128f"><span class="section-number-5">4.2.2.1</span> Resetting the Value of a Pointer after a delete</h5>
<div class="outline-text-5" id="text-4-2-2-1">
<p>
When we write
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">delete</span> p;
</pre>
</div>
<p>
p becomes undefined. Although p is undefined, on many machines, p still contains the address of
the object to which it pointed. However, the memory to which p points was freed, so p is no
longer valid.
</p>

<p>
After deleting a pointer, the pointer becomes what is referred to as a <b>dangling pointer</b>. A
dangling pointer is one that refers to memory that once held an object but does so no longer. A
dangling pointer can be the source of program errors that are difficult to detect.
</p>

<p>
<b>Best Practices</b>: <b><b>Setting the pointer to 0 after the object it refers to has been deleted</b></b> makes it
clear that the pointer points to no object.
</p>
</div>
</div>

<div id="outline-container-org3ca7c21" class="outline-5">
<h5 id="org3ca7c21"><span class="section-number-5">4.2.2.2</span> Common program errors</h5>
<div class="outline-text-5" id="text-4-2-2-2">
<ol class="org-ol">
<li>Failing to delete a pointer to dynamically allocated memory: <b><b>memory leak</b></b>.</li>
<li><b><b>Reading or writing the object after it has been deleted</b></b>. This error can sometimes be
detected by setting the pointer to 0 after deleting the object to which the pointer had
pointed.</li>
<li><b><b>Applying a delete expression to the same memory location twice</b></b>. This error can happen when
two pointers address the same dynamically allocated object. If delete is applied to one of
the pointers, then the object's memory is returned to the free store. If we subsequently
delete the second pointer, then the free store may be corrupted.</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-org1512ffe" class="outline-3">
<h3 id="org1512ffe"><span class="section-number-3">4.3</span> Type Conversions</h3>
</div>
</div>

<div id="outline-container-org3f68d35" class="outline-2">
<h2 id="org3f68d35"><span class="section-number-2">5</span> Statements</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org2e07ef9" class="outline-3">
<h3 id="org2e07ef9"><span class="section-number-3">5.1</span> try Blocks and Exception Handling</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">try</span> {
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">a throw Expression</span>
  <span style="color: #fa8072;">if</span> (iitem1.same_isbn(item2))
    <span style="color: #fa8072;">throw</span> runtime_error(<span style="color: #ffa07a;">"Data must refer to same ISBN"</span>);
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
 } <span style="color: #fa8072;">catch</span> (<span style="color: #9acd32; font-weight: bold;">runtime_error</span> <span style="color: #7fffd4; font-weight: bold;">err</span>) {
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">remind the user that ISBN must match</span>
  cout &lt;&lt; err.what() &lt;&lt; endl;
  exit(1);
 }
</pre>
</div>

<p>
<b><b>Each of the library exception classes</b></b> defines a member function named <b>what</b>. This function takes
no arguments and returns a C-style character string. In the case of runtime<sub>error</sub>, the C-style
string is a copy of the string that was used to initialize the runtime<sub>error</sub>.
</p>
</div>

<div id="outline-container-orgc6ec40d" class="outline-4">
<h4 id="orgc6ec40d"><span class="section-number-4">5.1.1</span> Standard Exceptions</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
Library exception classes are defined in four headers:
</p>
<ol class="org-ol">
<li>The <b><b>exception header</b></b> defines the most general kind of exception class named exception.It
communicates only that an exception occurs but provides no additional information.</li>
<li>The <b><b>stdexcept header</b></b> defines several general purpose exception classes.</li>
<li>The <b><b>new header</b></b> defines the <b><b>bad<sub>alloc</sub> exceptions type</b></b>, which is the exception <b><b>thrown by new</b></b>
if it cannot allocate memory.</li>
<li>The <b><b>type<sub>info</sub> header</b></b> defines the <b><b>bad<sub>cast</sub> exception type</b></b>.</li>
</ol>

<p>
The exception, bad<sub>alloc</sub>, and bad<sub>cast</sub> types define only a default constructor; it is not
possible to provide an initializer for objects of these types. The other exception types define
only a single constructor that takes a string initializer. That string initializer is used to
provide additional information about the error that occurred. The exception types define only a
<b><b>single operation</b></b> named <b><b>what</b></b>.
</p>

<p>
<b><b>Standard Exception Classes</b></b> Defined in &lt;stdexcept&gt; :: runtime<sub>error</sub>, range<sub>error</sub>, overflow<sub>error</sub>,
underflow<sub>error</sub>, logic<sub>error</sub>, domain<sub>error</sub>, invalid<sub>argument</sub>, length<sub>error</sub>, out<sub>of</sub><sub>range</sub>
</p>
</div>
</div>
</div>

<div id="outline-container-org8035c2b" class="outline-3">
<h3 id="org8035c2b"><span class="section-number-3">5.2</span> Using the Preprocessor for Debugging</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072; font-weight: bold;">#if</span><span style="color: #fa8072; font-weight: bold;">n</span><span style="color: #fa8072; font-weight: bold;">def</span> NDEBUG
cerr &lt;&lt; <span style="color: #ffa07a;">"starting main"</span> &lt;&lt;endl;
<span style="color: #fa8072; font-weight: bold;">#endif</span>
</pre>
</div>

<p>
By default, <b>NDEBUG</b> <b><b>is not defined</b></b>. When the program is being developed, we leave NDEBUG
undefined so that the debugging statements are executed. Most compilers provide a command line
option that defines NDEBUG:
&lt;example&gt;
$ CC -D NDEBUG main.c
&lt;/example&gt;
has the same effect as writing #define NDEBUG at the beginning of main.c.
</p>

<p>
The preprocessor defines four other constants that can be useful in debugging:
</p>
<ul class="org-ul">
<li>_<sub>FILE</sub>__   name of the file</li>
<li>_<sub>Line</sub>__   current line number</li>
<li>_<sub>TIME</sub>__   time the file was compiled</li>
<li>_<sub>DATE</sub>__   date the file was compiled</li>
</ul>

<p>
Another common debugging technique uses the <b><b>NDEBUG preprocessor variable</b></b> and the <b>assert</b>
<b>preprocessor macro</b>. The assert macro is defined in the <b><b>cassert</b></b> header.
</p>

<p>
A preprocessor macro acts something like a function call:
</p>
<div class="org-src-container">
<pre class="src src-c++">assert(expr)
</pre>
</div>

<p>
<b>As long as NDEBUG is not defined</b>, the assert <b><b>macro</b></b> <b><b>evaluates</b></b> the <b><b>condition</b></b> and if the result is
false, then assert writes a message and terminates the program. If the expression has a nonzero
value, then assert does nothing.
</p>

<p>
Unlike exceptions, programmers use assert to test conditions that "<b><b>cannot happen</b></b>." During
testing the assert has the effect of verifying that the data are always of the expected
size. Once development and test are complete, the program is built and NDEBUG is defined. In
production code, assert does nothing, so there is <b><b>no run-time cost</b></b>. Of course, there is also no
run-time check. Assert should be used only to verify things that truly should not be possible.
</p>
</div>
</div>
</div>

<div id="outline-container-org69808cc" class="outline-2">
<h2 id="org69808cc"><span class="section-number-2">6</span> Functions</h2>
<div class="outline-text-2" id="text-6">
<p>
<b><b>Beware</b></b>:
</p>
<ul class="org-ul">
<li>It is <b>illegal</b> to define or declare a <b><b>function without an explicit return type</b></b>.</li>
<li>When we call a function, the type of each argument must be either the <b><b>same type</b></b> as the
corresponding parameter <b><b>or</b></b> a type that <b><b>can be converted</b></b> to that type.</li>
</ul>
</div>

<div id="outline-container-org338abbf" class="outline-3">
<h3 id="org338abbf"><span class="section-number-3">6.1</span> Argument Passing</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-orgd903416" class="outline-4">
<h4 id="orgd903416"><span class="section-number-4">6.1.1</span> Pointer Parameters</h4>
<div class="outline-text-4" id="text-6-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">reset</span> (<span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">ip</span>) {
  *ip = 0;
  ip = 0;
}

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">... main function ...</span>
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span> = 42;
<span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">p</span> = &amp;i;
reset(p);     <span style="color: #add8e6;">// </span><span style="color: #add8e6;">changes *p but not p</span>
cout &lt;&lt; <span style="color: #ffa07a;">"i: "</span> &lt;&lt; *p &lt;&lt; endl;  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: print i: 0</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
</pre>
</div>

<p>
If we want to prevent changes to the value to which the pointer points, then the parameter
should be defined as a pointer to const:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">use_ptr</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">p</span>) {
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">use_ptr may read but not write to *p</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org14c17b9" class="outline-4">
<h4 id="org14c17b9"><span class="section-number-4">6.1.2</span> Reference Parameters</h4>
<div class="outline-text-4" id="text-6-1-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">swap</span> (<span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">v1</span>, <span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">v2</span>) {
  <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">tmp</span> = v2;
  v2 = v1;
  v1 = tmp;
}
</pre>
</div>

<p>
Like all references, reference parameters refer directly to the objects to which they are bound
rather than to copies of those objects. When we define a reference, we must initialize it with
the object to which the reference will be bound. Now, when we call
</p>
<div class="org-src-container">
<pre class="src src-c++">swap(i, j);
</pre>
</div>
<p>
the parameter v1 is <b><b>just another name</b></b> for the object i and v2 is another name for j. Any change
to v1 is actually a change to the argument i.
</p>

<p>
<b>Tips</b>: Programmers who come to C++ from a C background are used to passing pointers to obtain
access to the argument. <b><b>In C++ it is safer and more natural to use reference parameters</b></b>.
</p>
</div>

<div id="outline-container-org4683a4f" class="outline-5">
<h5 id="org4683a4f"><span class="section-number-5">6.1.2.1</span> Using (const) References to Avoid Copies</h5>
<div class="outline-text-5" id="text-6-1-2-1">
<p>
The other circumstance in which reference parameters are useful is when passing a large object
to a function.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">compare the length of two strings</span>
<span style="color: #9acd32; font-weight: bold;">bool</span> <span style="color: #7fffd4; font-weight: bold;">isShorter</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">s1</span>, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">s2</span>) {
  <span style="color: #fa8072;">return</span> s1.size() &lt; s2.size();
}
</pre>
</div>

<p>
Because strings can be long, we avoid copying them by using the references. Because the
parameters are const references, isShorter may not use the references to change the arguments.
</p>

<p>
<b>Note</b>: When the <b><b>only reason</b></b> to make a parameter a reference is to <b><b>avoid copying the argument</b></b>, the
parameter <b><b>should be</b></b> <b>const</b> reference. Defining such parameters as nonconst references <b><b>needlessly</b></b>
<b><b>restricts</b></b> the <b><b>usefulness</b></b> of a function.
</p>

<p>
Because a <b><b>nonconst</b></b> reference may be bound only to <b><b>nonconst</b></b> object of <b><b>exactly the same type</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">function takes a non-const reference parameter</span>
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">incr</span> (<span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">val</span>) {
  <span style="color: #fa8072;">return</span> ++val;
}

<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">main</span>() {
  <span style="color: #9acd32; font-weight: bold;">short</span> <span style="color: #7fffd4; font-weight: bold;">v1</span> = 0;
  <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">v2</span> = 42;
  <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">v3</span> = incr(v1);    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: v1 is not an int</span>
  v3 = incr(v2);        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: v2 is const</span>
  v3 = incr(v1 + v2);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: addition doesn't yield an lvalue</span>
  <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">v4</span> = incr(v3);    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: v3 is a nonconst object type int</span>
}
</pre>
</div>

<p>
As another example, we might write a program to find a given character in a string:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">returns index of first occurrence of c in s or s.size() if c isn't in s</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">Note: s doesn't change, so it *should be* a reference to const</span>
<span style="color: #7fffd4;">string</span>::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">find_char</span>(<span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">s</span>, <span style="color: #9acd32; font-weight: bold;">char</span> <span style="color: #7fffd4; font-weight: bold;">c</span>) {
  <span style="color: #7fffd4;">string</span>::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">i</span> = 0;
  <span style="color: #fa8072;">while</span> ( i != s.size() &amp;&amp; s[i] != c )
    ++i;                 <span style="color: #add8e6;">// </span><span style="color: #add8e6;">not found, look at next character</span>
  <span style="color: #fa8072;">return</span> i;
}
</pre>
</div>

<p>
One problem with this definition is that we <b><b>cannot</b></b> call it on a character string literal:
</p>

<div class="org-src-container">
<pre class="src src-c++">find_char( <span style="color: #ffa07a;">"hello World"</span>, <span style="color: #ffa07a;">'o'</span>);
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">....</span>
</pre>
</div>

<p>
This call fails at compile time, even though we can convert the literal to a string. Such
problem can be surprisingly pervasive.
</p>

<p>
<b><b>Best Practices</b></b>: Reference parameters that are not changed should be references to const. Plain,
nonconst reference parameters are less flexible. Such parameters may not be initialized by const
objects, or by arguments that are literals or expressions that yield rvalues.
</p>
</div>
</div>

<div id="outline-container-org61870a5" class="outline-5">
<h5 id="org61870a5"><span class="section-number-5">6.1.2.2</span> Passing a Reference to a Pointer</h5>
<div class="outline-text-5" id="text-6-1-2-2">
<p>
If we want to write a function that <b><b>swaps two pointers</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">swap values of two pointers to int</span>
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">ptrswap</span> ( <span style="color: #9acd32; font-weight: bold;">int</span> *&amp;<span style="color: #7fffd4; font-weight: bold;">v1</span>, <span style="color: #9acd32; font-weight: bold;">int</span> *&amp;<span style="color: #7fffd4; font-weight: bold;">v2</span> ) {
  <span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">tmp</span> = v2;
  v2 = v1;
  v1 = tmp;
}
</pre>
</div>

<p>
the parameter 'int *&amp;v1' should be read from right to left: v1 is a reference to a pointer to an
object of type int.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf58e65a" class="outline-4">
<h4 id="orgf58e65a"><span class="section-number-4">6.1.3</span> Array Parameters</h4>
<div class="outline-text-4" id="text-6-1-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">three equivalent definitions of print Values</span>
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">printValues</span> (<span style="color: #9acd32; font-weight: bold;">int</span> *) { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> }
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">printValues</span> (<span style="color: #9acd32; font-weight: bold;">int</span> []) { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> }
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">printValues</span> (<span style="color: #9acd32; font-weight: bold;">int</span> [10]) { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> }
</pre>
</div>

<p>
The compiler <b>ignores</b> any <b><b>dimension</b></b> we might specify for an array parameter: When the compiler
checks a argument to an array parameter, it checks only that the argument is a pointer and that
the types of the pointer and the array elements match. <b><b>The size of the array is not checked</b></b>.
</p>

<p>
It is usually a good idea to define array parameters as pointers, rather than using the array
syntax. Doing so makes it clear that what is being operated on is pointer to an array elelment,
not the array itself.
</p>
</div>

<div id="outline-container-orgd87852f" class="outline-5">
<h5 id="orgd87852f"><span class="section-number-5">6.1.3.1</span> Passing an Array by Reference</h5>
<div class="outline-text-5" id="text-6-1-3-1">
<p>
We can define an array parameter as a reference to the array. If the parameter is a reference to
the array, then a reference to the array is passed. In this case, the array size is part of the
parameter and argument types. <b><b>The compiler will check that the size of the array argument
matches the size of the parameter</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: parameter is a reference to an array, size of array if fixed.</span>
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">printValues</span> (<span style="color: #9acd32; font-weight: bold;">int</span> (&amp; <span style="color: #7fffd4; font-weight: bold;">arr</span>) [5]) {<span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span>}

<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">main</span>() {
  <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span> = 0, <span style="color: #7fffd4; font-weight: bold;">j</span>[2] = {0, 1}, <span style="color: #7fffd4; font-weight: bold;">k</span>[5] = {0, 1, 2, 3, 4};
  printValues(&amp;i);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: argument is not an array of 5 ints</span>
  printValues(j);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: argument is not an array of 5 ints</span>
  printValues(k);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">OK</span>
  <span style="color: #fa8072;">return</span> 0;
}
</pre>
</div>

<p>
This version of printValues <b><b>may</b></b> <b><b>be</b></b> <b><b>called</b></b> <b>only</b> for arrays of exactly 5 ints.
</p>

<p>
The parentheses around &amp;arr are <b><b>necessary</b></b> because of the higher precedence of the subscript
operator:
</p>
<div class="org-src-container">
<pre class="src src-c++">f(<span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">arr</span>[10])     <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: arr is an array of references</span>
f(<span style="color: #9acd32; font-weight: bold;">int</span> (&amp;<span style="color: #7fffd4; font-weight: bold;">arr</span>) [10])  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: arr is a reference to an array of 10 ints</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org17c2eb0" class="outline-5">
<h5 id="org17c2eb0"><span class="section-number-5">6.1.3.2</span> Passing a Multidimensioned Array</h5>
<div class="outline-text-5" id="text-6-1-3-2">
<p>
The size of the <b><b>second</b></b> (and any subsequent dimensions) is part of the element type and <b><b>must</b></b> be
specified:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">printValues</span>( <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">matrix</span>[][10], <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">rowSize</span>);
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">or</span>
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">printValues</span>( <span style="color: #9acd32; font-weight: bold;">int</span> (<span style="color: #9acd32; font-weight: bold;">matrix</span>*)[10], <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">rowSize</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2ee415" class="outline-5">
<h5 id="orgb2ee415"><span class="section-number-5">6.1.3.3</span> Functions with Varying Parameters</h5>
<div class="outline-text-5" id="text-6-1-3-3">
<p>
<b><b>Ellipsis parameters</b></b> are used when it is <b><b>impossible to list the type and number of all the</b></b>
<b><b>arguments</b></b> that might be passed to a function. Ellipsis suspend type checking. Ellipsis may take
either of two forms:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">foo</span>(parm_list, ...);
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">foo</span>(...);
</pre>
</div>

<p>
The first form provides declarations for a certain number of parameters. In this case, type
checking is performed when the function is called for the arguments that correspond to the
parameters that are explicitly declared, whereas type checking is suspended for the arguments
that correspond to the ellipsis.
</p>
</div>
</div>
</div>

<div id="outline-container-org2fd5a13" class="outline-4">
<h4 id="org2fd5a13"><span class="section-number-4">6.1.4</span> Return from main</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
There is one exception to the rule that a function with a return type other than void must
return a value: The main function is allowed to terminate without a return. If control reaches
the end of <b><b>main</b></b> and there is <b><b>no return</b></b>, then the compiler <b>implicitly</b> insert a <b><b>return of 0</b></b>.
</p>

<p>
The value returned from main is treated as a status indicator. A zero return indicates success;
most other values indicate failure. A nonzero value has a machine-dependent meaning. To make
return values machine-independent, the <b><b>cstdlib</b></b> header defines two preprocessor variables that we
can use to indicate success or failure:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">&lt;cstdlib&gt;</span>
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">main</span>() {
  <span style="color: #fa8072;">if</span> (some_failure)
    <span style="color: #fa8072;">return</span> EXIT_FAILURE;
  <span style="color: #fa8072;">else</span>
    <span style="color: #fa8072;">return</span> EXIT_SUCCESS;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org24d7828" class="outline-3">
<h3 id="org24d7828"><span class="section-number-3">6.2</span> Function Declarations</h3>
<div class="outline-text-3" id="text-6-2">
<p>
A function may be defined only once but may be declared multiple times. A function declaration
consists of a <b><b>return type</b></b>, the <b><b>function name</b></b>, and <b><b>parameter list</b></b>. The parameter list must
contain <b><b>the type of the parameters</b></b> but need <b><b>not</b></b> <b><b>name</b></b> of them. These three elements are referred
to as the <b>function prototype</b>.
</p>

<p>
Parameter names in a function declaration are ignored. If a name is given in a declaration, it
should serve as a documentation aid:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">print</span> ( <span style="color: #9acd32; font-weight: bold;">int</span> *<span style="color: #7fffd4; font-weight: bold;">array</span>, <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">size</span> );
</pre>
</div>
</div>

<div id="outline-container-org3dde317" class="outline-4">
<h4 id="org3dde317"><span class="section-number-4">6.2.1</span> Default Arguments</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
If a parameter has a default argument, all the parameters that follow it <b>must</b> also have default
arguments.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">String</span> <span style="color: #7fffd4; font-weight: bold;">screenInit</span>(<span style="color: #7fffd4;">string</span>::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">height</span> = 60,
                  <span style="color: #7fffd4;">string</span>::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">width</span> = 80,
                  <span style="color: #9acd32; font-weight: bold;">char</span> <span style="color: #7fffd4; font-weight: bold;">background</span> = <span style="color: #ffa07a;">' '</span>);

<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">screen</span>;
screen = screenInit();
screen = screenInit(66);
screen = screenInit(66, 256);
screen = screenInit(66, 256, <span style="color: #ffa07a;">'#'</span>);

screen = screenInit(, , <span style="color: #ffa07a;">'?'</span>);  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error, can omit only trailing arguments</span>
screen = screenInit(<span style="color: #ffa07a;">'?'</span>);      <span style="color: #add8e6;">// </span><span style="color: #add8e6;">calls screenInit ('?', 80, ' ')</span>
</pre>
</div>

<p>
Arguments to the call are <b><b>resolved by position</b></b>, and default arguments are used to <b><b>substitute</b></b> for
the <b><b>trailing arguments of a call</b></b>. If we want to specify an argument for background, we must also
supply arguments for height and width.
</p>

<p>
Part of the work of designing of a function with default arguments is ordering the parameters so
that those <b><b>least likely to use a default value appear first</b></b> and those <b><b>most likely to use a</b></b>
<b><b>default appear last</b></b>.
</p>

<p>
We can specify default argument(s) in <b><b>either the function definition or declaration</b></b>. However, a
parameter <b><b>can</b></b> have its default argument specified <b><b>only once</b></b> in a file. The following is an
error:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">ff.h</span>
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ff</span>(<span style="color: #9acd32; font-weight: bold;">int</span> = 0);

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">ff.cc</span>
<span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">"ff.h"</span>
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ff</span>(<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span> = 0) { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> }  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error</span>
</pre>
</div>

<p>
Default arguments ordinarily <b><b>should be specified with the declaration</b></b> for the function and
<b><b>placed in an appropriate header</b></b>.
</p>

<p>
If a default argument is provided in the parameter list of a function definition, the default
argument is available only for function calls in the source file that contains the function
definition.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfc15535" class="outline-3">
<h3 id="orgfc15535"><span class="section-number-3">6.3</span> Local Objects</h3>
<div class="outline-text-3" id="text-6-3">
</div>
<div id="outline-container-orgecd5704" class="outline-4">
<h4 id="orgecd5704"><span class="section-number-4">6.3.1</span> Automatic Objects</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
Objects that exist only while a function is executing are known as <b><b>automatic objects</b></b>. Automatic
objects are created and destroyed on each call to a function.
</p>
</div>
</div>

<div id="outline-container-org4f6aeb3" class="outline-4">
<h4 id="org4f6aeb3"><span class="section-number-4">6.3.2</span> Static Local Objects</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
A static local object is guaranteed to be initialized no later than the first time that program
execution passes through the object's definition. Once it is created, it is not destroyed until
the program terminates.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbd45dd3" class="outline-3">
<h3 id="orgbd45dd3"><span class="section-number-3">6.4</span> Inline Functions</h3>
<div class="outline-text-3" id="text-6-4">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">shorterString</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">s1</span>, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">s2</span>) {
  <span style="color: #fa8072;">return</span> s1.size() &lt; s2.size() ? s1 : s2;
}
</pre>
</div>

<p>
The benefits of defining a function for such a small operation include:
</p>
<ul class="org-ul">
<li>It is easier to read and understand.</li>
<li>If a change needs to be made, it is easier to change the function than to find and change
every occurrence of the equivalent expression.</li>
<li>Using a function ensures uniform behavior. Each test is guaranteed to be implemented in the
same manner.</li>
<li>The function can be reused rather than rewritten for other applications.</li>
</ul>

<p>
But calling a function is <b>slower</b> than evaluating the equivalent expression. On most machines, a
function call does a lot of work: registers are saved before the call and restored after the
return; the arguments are copied; and the program branches to a new location.
</p>
</div>

<div id="outline-container-orgec3a9bb" class="outline-4">
<h4 id="orgec3a9bb"><span class="section-number-4">6.4.1</span> inline Functions Avoid Function Call Overhead</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
A function specified as <b><b>inline</b></b> (usually) is <b><b>expanded "in line" at each point in the program</b></b> in
which it is invoked.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">inline</span> <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;
<span style="color: #7fffd4; font-weight: bold;">shorterString</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">s1</span>, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">s2</span>) {
  <span style="color: #fa8072;">return</span> s1.size() &lt; s2.size() ? s1 : s2;
}

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">then the call</span>

out &lt;&lt; shorterString(s1, s2) &lt;&lt; endl;

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">would be expanded *during compilation* into something like</span>

cout &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2
         &lt;&lt; endl;
</pre>
</div>

<p>
The run-time overhead of making shorterString a function is thus removed.
</p>

<p>
<b>Note</b>: The inline function specification is <b>only a request</b> to the compiler. The compiler may
choose to ignore this request.
</p>

<p>
In general, the inline mechanism is meant to optimize small, straight-line functions that are
called frequently. Many compilers will not inline a recursive function. A 1200-line function is
also not likely to be explanded inline.
</p>
</div>
</div>

<div id="outline-container-org323fb44" class="outline-4">
<h4 id="org323fb44"><span class="section-number-4">6.4.2</span> Put inline Functions in Header Files</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
Unlike other function definitions, inlines <b>should be defined in header files</b>. To expand the code
of an inline function at the point of call, the compiler must have access to the function
definition. The function prototype is insufficient.
</p>
</div>
</div>
</div>

<div id="outline-container-org1da0271" class="outline-3">
<h3 id="org1da0271"><span class="section-number-3">6.5</span> Class Member Functions</h3>
<div class="outline-text-3" id="text-6-5">
</div>
<div id="outline-container-org107b45b" class="outline-4">
<h4 id="org107b45b"><span class="section-number-4">6.5.1</span> Defining the Body of a Member Function</h4>
<div class="outline-text-4" id="text-6-5-1">
<p>
We <b>must</b> <b><b>declare all the members of a class within the curly braces</b></b> that delimit the class
definition. There is <b><b>no way</b></b> to subsequently <b><b>add</b></b> any members to the class. We can <b><b>define</b></b> a member
function <b><b>either outside or inside</b></b> of the class definition. A member function that is <b><b>defined</b></b>
<b><b>inside</b></b> the class is <b><b>implicitly</b></b> treated as an <b><b>inline</b></b> function.
</p>
</div>
</div>

<div id="outline-container-org219cb4d" class="outline-4">
<h4 id="org219cb4d"><span class="section-number-4">6.5.2</span> Introducing this</h4>
<div class="outline-text-4" id="text-6-5-2">
<p>
Each member function (except for static member function) has an extra, implicit parameter named
<b>this</b>. When a member function is called, the this parameter is initialized with the address of
the object on which the function was invoked.
</p>

<p>
When we write
</p>
<div class="org-src-container">
<pre class="src src-c++">total.same_isbn(trans);
</pre>
</div>
<p>
it is as if the compiler rewrites the call as
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">Sales_item</span>::same_isbn(&amp;total, trans);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">pseudo-code</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4a7bceb" class="outline-4">
<h4 id="org4a7bceb"><span class="section-number-4">6.5.3</span> Introducing const Member Functions</h4>
<div class="outline-text-4" id="text-6-5-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #add8e6;">//</span><span style="color: #add8e6;">...</span>
  <span style="color: #9acd32; font-weight: bold;">bool</span> <span style="color: #7fffd4; font-weight: bold;">same_isbn</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> &amp;<span style="color: #7fffd4; font-weight: bold;">rhs</span>) <span style="color: #fa8072;">const</span>
  { <span style="color: #fa8072;">return</span> isbn == rhs.isbn; }
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
};
</pre>
</div>

<p>
<b><b>const</b></b> that follows the parameter lists in the declarations of the Sales<sub>item</sub> member functions
<b><b>modifies the</b></b> <b><b>type of the implicit this parameter</b></b>. When we call total.same<sub>isbn</sub>(trans), the
implicit <b><b>this</b></b> parameter will be a <b><b>const</b></b> Sales<sub>Item</sub>* that points to total. It is as if the body
of same<sub>isbn</sub> were written as
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">bool</span> <span style="color: #7fffd4;">Sales_item</span>::<span style="color: #7fffd4; font-weight: bold;">same_isbn</span> ( <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> *<span style="color: #fa8072;">const</span> <span style="color: #fa8072;">this</span>,
                             <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> &amp;<span style="color: #7fffd4; font-weight: bold;">rhs</span>) <span style="color: #fa8072;">const</span>
{ <span style="color: #fa8072;">return</span> (<span style="color: #fa8072;">this</span>-&gt;isbn == rhs.isbn); }
</pre>
</div>

<p>
A function that uses const in this way is called a <b><b>const member function</b></b>. Because this is a
pointer to const, a const member function cannot changed the object on whose behalf the function
is called.
</p>
</div>
</div>

<div id="outline-container-org5aa4cad" class="outline-4">
<h4 id="org5aa4cad"><span class="section-number-4">6.5.4</span> Using the this Pointer</h4>
<div class="outline-text-4" id="text-6-5-4">
<p>
Inside a member function, we <b><b>need not explicitly use the this pointer to access the member of</b></b>
<b><b>the object</b></b> on which the function was called. Any unqualified reference to a member of our class
is assumed to be a reference through this.
</p>

<p>
The this parameter is defined implicitly, so it is <b><b>unnecessary</b></b> and in fact <b>illegal</b> to include
the this pointer in the function's parameter list. However, in the body of the function we <b><b>can</b></b>
refer to the this pointer explicitly:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">bool</span> <span style="color: #7fffd4; font-weight: bold;">same_isbn</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> &amp;<span style="color: #7fffd4; font-weight: bold;">rhs</span>) <span style="color: #fa8072;">const</span>
{ <span style="color: #fa8072;">return</span> <span style="color: #fa8072;">this</span>-&gt;isbn == rhs.isbn; }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgab26209" class="outline-4">
<h4 id="orgab26209"><span class="section-number-4">6.5.5</span> Defining a Member Function Outside the Class</h4>
<div class="outline-text-4" id="text-6-5-5">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4;">Sales_item</span>::<span style="color: #7fffd4; font-weight: bold;">avg_price</span>() <span style="color: #fa8072;">const</span> { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> }
</pre>
</div>

<p>
Sales<sub>item</sub>::avg<sub>price</sub> uses the scope operator to say that we are defining the function named
avg<sub>price</sub> that is defined in the scope of the Sales<sub>item</sub> class.
</p>

<p>
If the function is declared to be a const member function (like here), then the const after the
parameter list must be included in the definition as well.
</p>
</div>
</div>

<div id="outline-container-org9a630bd" class="outline-4">
<h4 id="org9a630bd"><span class="section-number-4">6.5.6</span> Writing the Sales<sub>item</sub> Constructor</h4>
<div class="outline-text-4" id="text-6-5-6">
<p>
A <b><b>constructor</b></b> is a <b><b>special member function</b></b> that <b><b>has</b></b> the <b><b>same names as its class</b></b>. Unlike other
member functions, constructors have <b><b>no return type</b></b>. A class can have multiple constructors. Each
constructor must differ from the others in the number or types of its parameters.
</p>

<p>
A constructor is declared inside the class and may be defined there or outside the class.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #7fffd4; font-weight: bold;">Sales_item</span>() : units_sold(0), revenue(0.0) {}
  <span style="color: #add8e6;">//</span><span style="color: #add8e6;">...</span>
};
</pre>
</div>

<p>
This constructor says We are Defining a constructor for the Sales<sub>item</sub> class that has an empty
parameter list and an empty function body.
</p>

<p>
The colon and the following text up to the open curly is the <b><b>constructor initializer list</b></b>. A
constructor initializer list specified initial values for one or more data members of the
class. When we do not specify initial values for some members, members that are of class type
are automatically initialized bay that class' default constructor.
</p>
</div>
</div>

<div id="outline-container-org8c05526" class="outline-4">
<h4 id="org8c05526"><span class="section-number-4">6.5.7</span> Synthesized Default Constructor</h4>
<div class="outline-text-4" id="text-6-5-7">
<p>
If we do not explicitly define any constructors, then the compiler will generate the default
constructor &#x2013; <b><b>synthesized default constructor</b></b>. It initializes each member using the same
rules as are applied for variable initializations.
</p>

<p>
Members that are of class type are initialized by using the default constructor of the member's
own class. The initial value of members of built-in type depend on how the object is defined. If
the object is defined at global scope (outside any function) or is a local static object, then
these members will be initialized to 0. If the object is defined at local scope, these members
are uninitialized.
</p>

<p>
The synthesized default constructor often <b><b>suffices for classes that contain only members of</b></b>
<b><b>class type</b></b>. Classes with members of built-in or compound type should usually define their own
default constructors to initialize those members.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb8f78ce" class="outline-3">
<h3 id="orgb8f78ce"><span class="section-number-3">6.6</span> Overloaded Functions</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Two functions that appear in the same scope are <b>overloaded</b> if they have the <b><b>same name</b></b> but have
<b><b>different parameter lists</b></b>.
</p>

<p>
Note: The main function <b><b>may not</b></b> be overloaded.
</p>
</div>

<div id="outline-container-orgbbbc126" class="outline-4">
<h4 id="orgbbbc126"><span class="section-number-4">6.6.1</span> Distinguishing Overloading from Redeclaring a Function</h4>
<div class="outline-text-4" id="text-6-6-1">
<p>
If the return type and parameter list of two functions declarations match exactly, then the
second declaration is treated as a <b><b>redeclaration</b></b> of the first. If the parameter lists of two
functions match exactly but the return types differ, then the second declaration is an <b>error</b>.
So: <b><b>Functions cannot be overloaded based only on differences in the return type</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">Record</span> <span style="color: #7fffd4; font-weight: bold;">lookup</span> (Phone);
<span style="color: #9acd32; font-weight: bold;">Record</span> <span style="color: #7fffd4; font-weight: bold;">lookup</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Phone</span>); <span style="color: #add8e6;">// </span><span style="color: #add8e6;">redeclaration</span>
</pre>
</div>

<p>
This pair differs only as to whether the parameter is const. When the parameter is copied,
whether the parameter is const is irrelevant &#x2013; the function executes on a copy. The two
parameters are indistinguishable. But a function that takes a const reference is different from
on that takes a nonconst reference. Similarly, a function that takes a pointer to a const type
differs from a function that takes a pointer to the nonconst object of the same type.
</p>
</div>
</div>

<div id="outline-container-org15df0fb" class="outline-4">
<h4 id="org15df0fb"><span class="section-number-4">6.6.2</span> Overloading and Scope</h4>
<div class="outline-text-4" id="text-6-6-2">
<p>
If we declare a function locally, that function <b>hides</b> <b><b>rather than overloads</b></b> the same function
declared in an outer scope. ( In general, it is a bad idea to declare a function
locally. Function declarations should go in header files. )
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">print</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;);
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">print</span> (<span style="color: #9acd32; font-weight: bold;">double</span>);
<span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">fooBar</span> (<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ival</span>) {
  <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">print</span> (<span style="color: #9acd32; font-weight: bold;">int</span>);  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">new scope: hides previous instances of print</span>
  print (<span style="color: #ffa07a;">"value: "</span>) ;
  print (ival);      <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: print (int) is visible</span>
}
</pre>
</div>

<p>
When we call print, the compiler first looks for a declaration of that name. It finds the local
declaration for print that takes an int. Once the name is found, the compiler does no further
checks to see if the name exists in an outer scope.
</p>
</div>
</div>

<div id="outline-container-orga348e76" class="outline-4">
<h4 id="orga348e76"><span class="section-number-4">6.6.3</span> Function Matching and Argument Conversions</h4>
<div class="outline-text-4" id="text-6-6-3">
<p>
The compiler matches a call to a function automatically by comparing the actual arguments used
in the call with the parameters offered by each function in the overload set. There are three
possible outcomes:
</p>
<ol class="org-ol">
<li>The compiler finds one function that is a <b><b>best match</b></b> for the actual arguments and generates
code to call that function.</li>
<li>There is no function with parameters that match the arguments in the call, in which case the
compiler indicates a compile-time error.</li>
<li>There is more than one function that matches and none of the matches is clearly best. this
case is also an error; the call is <b><b>ambiguous</b></b>.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org10e16c2" class="outline-3">
<h3 id="org10e16c2"><span class="section-number-3">6.7</span> Pointers to Functions</h3>
<div class="outline-text-3" id="text-6-7">
<p>
Like any other pointer, a function pointer <b><b>points to a particular type</b></b>. A function's type is
determined by its return type and its parameter list. A function's name is not part of its type:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">bool</span> (*<span style="color: #7fffd4; font-weight: bold;">pf</span>) (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;);
</pre>
</div>

<p>
This statement declares pf to be a pointer to a function that takes two const string &amp;
parameters and has a return type of bool.
</p>

<p>
Note: The parentheses around *pf are necessary:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">declares a function named pf that returns a bool *</span>
<span style="color: #9acd32; font-weight: bold;">bool</span> *<span style="color: #7fffd4; font-weight: bold;">pf</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;);
</pre>
</div>
</div>

<div id="outline-container-orgfdab165" class="outline-4">
<h4 id="orgfdab165"><span class="section-number-4">6.7.1</span> Using Typedef to Simplify Function Pointer Definitions</h4>
<div class="outline-text-4" id="text-6-7-1">
<p>
Function pointer types can quickly become unwieldy. We can make function pointers easier to use
by defining a <b><b>synonym for the pointer type</b></b> using a typedef.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">typedef</span> <span style="color: #9acd32; font-weight: bold;">bool</span> (*<span style="color: #9acd32; font-weight: bold;">cmpFcn</span>) (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;);
</pre>
</div>

<p>
This definition says that cmpFcn is the name of a type that is a pointer to function. That
pointer has the type "pointer to a function that returns a bool and takes two references to
const string."
</p>
</div>
</div>

<div id="outline-container-orgaf7bead" class="outline-4">
<h4 id="orgaf7bead"><span class="section-number-4">6.7.2</span> Initializing and Assigning Pointers to Functions</h4>
<div class="outline-text-4" id="text-6-7-2">
<p>
When we use a function name without calling it, the name is automatically treated as a pointer
to a function. Given
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">bool</span> <span style="color: #7fffd4; font-weight: bold;">lengthCompare</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;);
</pre>
</div>

<p>
any use of lengthCompare, except as the left-hand operand of a function call, is treated as a
pointer whose type 'bool (*) (const string &amp;, const string &amp;)'. We can use a function name to
initialize or assign to a function pointer:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">comFcn</span> <span style="color: #7fffd4; font-weight: bold;">pf1</span> = 0;               <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: unbound pointer to function</span>
<span style="color: #9acd32; font-weight: bold;">cmpFcn</span> <span style="color: #7fffd4; font-weight: bold;">pf2</span> = lengthCompare;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: pointer type matches function's type</span>
pf2 = pf1;

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">Using the function name is equivalent to applying</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">the address-of operator to the function name</span>
<span style="color: #9acd32; font-weight: bold;">comFcn</span> <span style="color: #7fffd4; font-weight: bold;">pf3</span> = &amp;lengthCompare;

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">There is no conversion between one pointer to function type and another</span>
<span style="color: #9acd32; font-weight: bold;">bool</span> <span style="color: #7fffd4; font-weight: bold;">cstringCompare</span>(<span style="color: #9acd32; font-weight: bold;">char</span>*, <span style="color: #9acd32; font-weight: bold;">char</span>*);
<span style="color: #7fffd4;">string</span>::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">sumLength</span>(<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;);
pf1 = cstringCompare;         <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: parameter types differ</span>
pf1 = sumLength;              <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: return type differ</span>
</pre>
</div>

<p>
Initializing a function pointer to zero indicates that the pointer does not point to any
function.
</p>
</div>
</div>

<div id="outline-container-org9c75cd9" class="outline-4">
<h4 id="org9c75cd9"><span class="section-number-4">6.7.3</span> Calling a Function through a Pointer</h4>
<div class="outline-text-4" id="text-6-7-3">
<p>
We can use the pointer directly &#x2013; there is <b><b>no need to use the dereference operator</b></b> to call the
function.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">compFcn</span> <span style="color: #7fffd4; font-weight: bold;">pf</span> = lengthCompare;
lengthCompare(<span style="color: #ffa07a;">"hi"</span>, <span style="color: #ffa07a;">"bye"</span>);        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">direct call</span>
pf(<span style="color: #ffa07a;">"hi"</span>, <span style="color: #ffa07a;">"bye"</span>);                   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">equivalent call</span>
(*pf) (<span style="color: #ffa07a;">"hi"</span>, <span style="color: #ffa07a;">"bye"</span>);               <span style="color: #add8e6;">// </span><span style="color: #add8e6;">equivalent call</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org6a36cd4" class="outline-2">
<h2 id="org6a36cd4"><span class="section-number-2">7</span> The IO Library</h2>
<div class="outline-text-2" id="text-7">
<p>
The IO types are defined in three separate headers:
</p>
<ul class="org-ul">
<li>iostream defines the types used to read and write to a <b><b>console window</b></b>.</li>
<li>fstream defines the types used to read and write <b><b>named files</b></b>.</li>
<li>sstream defines the types used to read and write <b><b>in-memory strings</b></b>.</li>
</ul>


<div id="org418a9ca" class="figure">
<p><img src="./pic/iostream_inheritance_hierarchy.png" alt="iostream_inheritance_hierarchy.png" />
</p>
</div>

<p>
Because the types ifstream and istringstream inherit from istream, each program we've written
that read an istream could be used to read a file (using the ifstream type) or a string (using
the istringstream type). Similarly, programs that did output could use an ofstream or
ostringstream instead of ostream.
</p>

<p>
Using inheritance for the IO types has another import implication: When we have a function that
takes a reference to a base-class type, we can <b><b>pass an object of a derived type to that</b></b>
<b><b>function</b></b>. This fact means that a function written to operate on istream&amp; can be called with an
ifstream or istringstream object.
</p>
</div>

<div id="outline-container-org9ce4abb" class="outline-4">
<h4 id="org9ce4abb"><span class="section-number-4">7.0.1</span> International Character Support</h4>
<div class="outline-text-4" id="text-7-0-1">
<p>
The stream classes described thus far read and write streams composed of type <b><b>char</b></b>. The library
defines a corresponding set of types supporting the <b><b>wchar<sub>t</sub></b></b> type. Each class is distinguished
from its char counterpart by a "w" prefix. Thus, the types wostream, wistream, and wiostream
read and write wchar<sub>t</sub> data to or from a console window&#x2026; The wchar<sub>t</sub> standard input object is
named wcin; standard output is wcout; and standard error is wcerr.
</p>
</div>
</div>

<div id="outline-container-orgdbdb86f" class="outline-4">
<h4 id="orgdbdb86f"><span class="section-number-4">7.0.2</span> No Copy or Assign for IO Objects</h4>
<div class="outline-text-4" id="text-7-0-2">
<p>
IO Objects <b><b>do not allow copy or assignment</b></b>. This requirement has two particularly important
implications:
</p>
<ol class="org-ol">
<li>Only element types that support copy can be stored in vectors or other container types, and
we cannot copy objects, so we <b><b>cannot have a vector (or other container) that holds stream</b></b>
<b><b>objects</b></b>.</li>
<li>We <b><b>cannot have a parameter or return type that is one of the stream types</b></b>. If we need to
pass or return an IO object, it must be passed or returned as a pointer or reference:</li>
</ol>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">ofstream</span> &amp;<span style="color: #7fffd4; font-weight: bold;">print</span> (<span style="color: #9acd32; font-weight: bold;">ofstream</span>&amp;);      <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: takes a reference, no copy</span>
<span style="color: #fa8072;">while</span> (print (out2)) { <span style="color: #add8e6;">/*</span><span style="color: #add8e6;">...</span><span style="color: #add8e6;">*/</span> }  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: pass reference to out2</span>
</pre>
</div>

<p>
<b><b>Reading</b></b> or <b><b>writing</b></b> an IO object <b><b>changes its state</b></b>, so the reference must be <b><b>nonconst</b></b>.
</p>
</div>
</div>

<div id="outline-container-org7b84aae" class="outline-3">
<h3 id="org7b84aae"><span class="section-number-3">7.1</span> Condition States</h3>
<div class="outline-text-3" id="text-7-1">
<p>
strm::iostate    |  Name of the machine-dependent integral type
strm::badbit     |  strm::iostate value used to indicate that a stream is <b><b>corrupted</b></b>.
strm::failbit    |  strm::iostate value used to indicate that an IO operation <b><b>failed</b></b>.
strm::eofbit     |  strm::iostate value used to indicate the a stream hit <b><b>end-of-file</b></b>.
**s.eof**()          |  true if eofbit in the stream s is set.
**s.fail**()         |  true if failbit in the stream s is set.
**s.bad**()          |  true if badbit in the stream s is set.
**s.good**()         |  true if the stream s is in a valid state.
s.clear()        |  Reset all condition values in the stream s to valid state.
s.clear(flag)    |  Set specified condition state(s) in s to valid. Type of flag is strm::iostate.
s.setstate(flag) |  Add specified condition to s. Type of flag is strm::iostate.
s.rdstate()     ||| Returns current condition of s as an strm::iostate value.
</p>

<ul class="org-ul">
<li>The <b><b>badbit</b></b> indicates a <b><b>system level failure</b></b>, such as an unrecoverable read or write error. It
is usually not possible to continue using a stream after such an error.</li>
<li>The failbit is set after a <b><b>recoverable error</b></b>, such as reading a character when numeric data
was expected.</li>
<li>eofbit is set when an end-of-file is encountered. <b><b>Hitting end-of-file also sets the failbit</b></b>.</li>
</ul>

<p>
Dealing with Multiple States:
</p>

<div class="org-src-container">
<pre class="src src-c++">is.setstate(<span style="color: #7fffd4;">ifstream</span>::badbit | <span style="color: #7fffd4;">ifstream</span>::failbit);
</pre>
</div>
</div>

<div id="outline-container-org4ceb73f" class="outline-4">
<h4 id="org4ceb73f"><span class="section-number-4">7.1.1</span> Interrogating and Controlling the State of a Stream</h4>
<div class="outline-text-4" id="text-7-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ival</span>;
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">read cin and test only for EOF; loop is executed even if there are other IO failures</span>
<span style="color: #fa8072;">while</span> (cin &gt;&gt; ival, !cin.eof()) {
  <span style="color: #fa8072;">if</span> (cin.bad())         <span style="color: #add8e6;">// </span><span style="color: #add8e6;">input stream is corrupted; bail out</span>
    <span style="color: #fa8072;">throw</span> runtime_error(<span style="color: #ffa07a;">"IO stream corrupted"</span>);
  <span style="color: #fa8072;">if</span> (cin.fail()) {                        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">bad input</span>
    cerr &lt;&lt; <span style="color: #ffa07a;">"bad data, try again"</span>;       <span style="color: #add8e6;">// </span><span style="color: #add8e6;">warn the user</span>
    cin.clear(<span style="color: #7fffd4;">istream</span>::failbit);         <span style="color: #add8e6;">// </span><span style="color: #add8e6;">reset the stream</span>
    <span style="color: #fa8072;">continue</span>;                            <span style="color: #add8e6;">// </span><span style="color: #add8e6;">get next input</span>
  }
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok to process ival</span>
 }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd69edcc" class="outline-3">
<h3 id="orgd69edcc"><span class="section-number-3">7.2</span> Managing the Output Buffer</h3>
<div class="outline-text-3" id="text-7-2">
<p>
There are several conditions that cause the buffer to be flushed to the actual output device or file:
</p>
<ul class="org-ul">
<li>The program completes normally.</li>
<li>Buffer becomes full.</li>
<li>flush the buffer explicitly using a manipulator, such as endl.</li>
<li>use the <b><b>unitbuf</b></b> manipulator to set the stream's internal state to empty the buffer after each
output operation.</li>
<li>tie the output stream to an input stream, in which case the output buffer is flushed whenever
the associated input stream is read.</li>
</ul>

<p>
<b><b>flush, ends, endl</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-c++">cout &lt;&lt; <span style="color: #ffa07a;">"hi"</span> &lt;&lt; flush;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">flushes the buffer; adds no data</span>
cout &lt;&lt; <span style="color: #ffa07a;">"hi"</span> &lt;&lt; ends;    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">inserts a null, then flushes the buffer</span>
cout &lt;&lt; <span style="color: #ffa07a;">"hi"</span> &lt;&lt; endl;    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">flushes a newline; then flushes the buffer</span>
</pre>
</div>

<p>
<b><b>unitbuf</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-c++">cout &lt;&lt; unitbuf &lt;&lt; <span style="color: #ffa07a;">"first"</span> &lt;&lt; <span style="color: #ffa07a;">" second"</span> &lt;&lt; nounitbuf;
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">equal to</span>
cout &lt;&lt; <span style="color: #ffa07a;">"first"</span> &lt;&lt; flush &lt;&lt; <span style="color: #ffa07a;">" second"</span> &lt;&lt; flush;
</pre>
</div>

<p>
The <b><b>nounitbuf</b></b> manipulator <b><b>restores</b></b> the stream to use normal buffer flushing.
</p>

<p>
<b><b>tie</b></b>:
</p>

<p>
When an input stream is tied to an output stream, any attempt to read the input stream will
first flush the buffer associated output stream. The tie function can be called on either
istream or an ostream. It takes a pointer to an ostream and ties the argument stream to the
object on which tie was called.
</p>

<div class="org-src-container">
<pre class="src src-c++">cin.tie(&amp;cout);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">illustration only: the library ties cin and cout for us</span>
<span style="color: #9acd32; font-weight: bold;">ostream</span> *<span style="color: #7fffd4; font-weight: bold;">old_tie</span> = cin.tie();
cin.tie(0);       <span style="color: #add8e6;">// </span><span style="color: #add8e6;">break tie to cout</span>
cin.tie(old_tie); <span style="color: #add8e6;">// </span><span style="color: #add8e6;">restablish normal tie between cin and cout</span>
</pre>
</div>

<p>
<b>Caution</b>: Output buffers are <b><b>not flushed</b></b> if the program <b><b>terminates abnormally</b></b>.
If you use the last output to help locate the bug, you need to be certain that all the output
really did get printed. Making sure that <b><b>all output operations include an explicit flush</b></b> or <b><b>call</b></b>
<b><b>to endl</b></b> is the <b><b>best way to ensure</b></b> that you are <b><b>seeing all the output</b></b> that the program actually
processed.
</p>
</div>
</div>

<div id="outline-container-org77628ff" class="outline-3">
<h3 id="org77628ff"><span class="section-number-3">7.3</span> File Input and Output</h3>
<div class="outline-text-3" id="text-7-3">
<p>
The <b><b>fstream</b></b> header defines three types to support file IO:
</p>
<ul class="org-ul">
<li>ifstream, derived from istream, reads from a file</li>
<li>ofstream, derived from ostream, writes to a file</li>
<li>fstream, derived from iostream, reads and writes the same file</li>
</ul>

<p>
In addition to the behavior that fstream types inherit, they also define two new operations:
<b>open</b> and <b>close</b>.
</p>
</div>

<div id="outline-container-org20f4cdd" class="outline-4">
<h4 id="org20f4cdd"><span class="section-number-4">7.3.1</span> Using File Stream Objects</h4>
<div class="outline-text-4" id="text-7-3-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">construct an ifstream and bind it to the file named ifile</span>
<span style="color: #9acd32; font-weight: bold;">ifstream</span> <span style="color: #7fffd4; font-weight: bold;">infile</span> (ifile.c_str());
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">ofstream output file object to write file named ofile</span>
<span style="color: #9acd32; font-weight: bold;">ofstream</span> <span style="color: #7fffd4; font-weight: bold;">outfile</span>(ofile.c_str());

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">or:</span>
<span style="color: #9acd32; font-weight: bold;">ifstream</span> <span style="color: #7fffd4; font-weight: bold;">infile</span>;  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">unbound input file stream</span>
<span style="color: #9acd32; font-weight: bold;">ofstream</span> <span style="color: #7fffd4; font-weight: bold;">outfile</span>; <span style="color: #add8e6;">// </span><span style="color: #add8e6;">unbound output file stream</span>
infile.open(ifile.c_str());
outfile.open(ofile.c_str());
</pre>
</div>

<p>
<b>Caution</b>: File Names In C++
</p>

<p>
For historical reasons, the IO library uses <b><b>C-style character string</b></b> rather than C++ strings
to <b><b>refer to file names</b></b>. Often our programs obtain file names by reading the standard
input. As usual, it is a good idea to read into a string, not a C-style character
array. Assuming that the name of the file we wish to use is in a string, we can use the <b><b>c<sub>str</sub></b></b>
<b><b>member</b></b> to obtain a C-style string.
</p>
</div>
</div>

<div id="outline-container-orgb096802" class="outline-4">
<h4 id="orgb096802"><span class="section-number-4">7.3.2</span> Rebinding a File Stream to a New File</h4>
<div class="outline-text-4" id="text-7-3-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">ifstream</span> <span style="color: #7fffd4; font-weight: bold;">infile</span>(<span style="color: #ffa07a;">"in"</span>)
  infile.close()
  infile.open(<span style="color: #ffa07a;">"next"</span>)
</pre>
</div>

<p>
It is <b><b>essential</b></b> that we <b><b>close</b></b> a file stream <b><b>before</b></b> attempting to <b><b>open</b></b> a new file. The open
function checks whether the stream is already open. If it is open, then it sets its internal
state to indicate that a failure has happened.
</p>
</div>
</div>

<div id="outline-container-org4a2c2f3" class="outline-4">
<h4 id="org4a2c2f3"><span class="section-number-4">7.3.3</span> Clearing the State of a File Stream</h4>
<div class="outline-text-4" id="text-7-3-3">
<p>
Consider a program that has a vector containing names of files it should open and read, doing
some processing on the words stored in each file. And the vector is named files:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">ifstream</span> <span style="color: #7fffd4; font-weight: bold;">input</span>;
<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>&gt;::<span style="color: #9acd32; font-weight: bold;">const_iterator</span> <span style="color: #7fffd4; font-weight: bold;">it</span> = files.begin();
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">for each file in the vector</span>
<span style="color: #fa8072;">while</span> (it != files.end()) {
  input.open(it-&gt;c_str());  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">open the file</span>
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">if the file is ok, read and "process" the input</span>
  <span style="color: #fa8072;">if</span> (!input)
    <span style="color: #fa8072;">break</span>;                <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: bail out!</span>
  <span style="color: #fa8072;">while</span> (input &gt;&gt; s)
    process(s);
  input.close();            <span style="color: #add8e6;">// </span><span style="color: #add8e6;">close file when we're done with it</span>
  input.clear();            <span style="color: #add8e6;">// </span><span style="color: #add8e6;">reset state to ok</span>
  ++it;
 }
</pre>
</div>

<p>
If we <b><b>reuse</b></b> a <b><b>file stream</b></b> to read or write more than one file, we must <b><b>clear the stream</b></b> before
using it to read from another file.
</p>
</div>
</div>

<div id="outline-container-org32de691" class="outline-4">
<h4 id="org32de691"><span class="section-number-4">7.3.4</span> file Modes</h4>
<div class="outline-text-4" id="text-7-3-4">
<p>
in      |  open for input
out     |  open output
app     |  seek to the end before every write
ate     |  seek to the end immediately after the open
trunc   |  truncate an existing stream when opening it
binary ||| do IO operations in binary mode
</p>

<p>
By default, files associated with an <b><b>ifstream</b></b> are opened in <b><b>in</b></b> mode. Files opened by an <b><b>ofstream</b></b>
are opened in <b><b>out</b></b> mode.
</p>

<p>
By default, an fstream is opened with both in and out set. A file opened with both in and out
mode set is not truncated. If we open the file associated with an fstream with out mode, then
the file is truncated.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">ofstream</span> <span style="color: #7fffd4; font-weight: bold;">outfile1</span>(<span style="color: #ffa07a;">"file1"</span>, <span style="color: #7fffd4;">ofstream</span>::out | <span style="color: #7fffd4;">ofstream</span>::trunc);
<span style="color: #9acd32; font-weight: bold;">ofstream</span> <span style="color: #7fffd4; font-weight: bold;">outfile2</span>(<span style="color: #ffa07a;">"file2"</span>, <span style="color: #7fffd4;">ofstream</span>::app);
</pre>
</div>
</div>

<div id="outline-container-orgba8d546" class="outline-5">
<h5 id="orgba8d546"><span class="section-number-5">7.3.4.1</span> Valid Combinations for Open Mode</h5>
<div class="outline-text-5" id="text-7-3-4-1">
<p>
&lt;example&gt;
out               : open for output; deletes existing data in the file
out | app         : open for output; all writes at end of file
out | trunc       : same as out
in                : open for input
in | out          : open for both input and output; positioned to read the beginning of the file
in | out | trunc  : open for both input and output, deletes existing data in the file
&lt;/example&gt;
</p>

<p>
Any open mode combination may also include <b><b>ate</b></b>. Adding ate to any of these mode combinations
positions the file to the end before the first input or output operation is performed.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org0a12548" class="outline-3">
<h3 id="org0a12548"><span class="section-number-3">7.4</span> String Streams</h3>
<div class="outline-text-3" id="text-7-4">
<p>
The <b><b>sstream</b></b> header defines three kinds of string streams:
</p>
<ul class="org-ul">
<li><b><b>istringstream</b></b>, derived from istream, reads from a string</li>
<li><b><b>ostringstream</b></b>, derived from ostream, writes to a string</li>
<li><b><b>stringstream</b></b>, derived from iostream, reads and writes a string</li>
</ul>

<p>
<b><b>stringstream-Specific Operations</b></b>:
stringstream strm;        |   Creates an unbound stringstream.
stringstream strm(s);     |   Creates a stringstream that holds a copy of the string s.
strm.str()                |   Returns a copy of the string that strm holds.
strm.str(s)               |   Copies the string s into strm. Retrun void.
</p>
</div>

<div id="outline-container-org8969ef0" class="outline-4">
<h4 id="org8969ef0"><span class="section-number-4">7.4.1</span> Using a Stringsteam</h4>
<div class="outline-text-4" id="text-7-4-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">line</span>, <span style="color: #7fffd4; font-weight: bold;">word</span>;      <span style="color: #add8e6;">// </span><span style="color: #add8e6;">will hold a line and word from input, respectively</span>
<span style="color: #fa8072;">while</span> (getline(cin, line))   {            <span style="color: #add8e6;">// </span><span style="color: #add8e6;">read a line from the input into line</span>
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">do per-line processing</span>
  <span style="color: #9acd32; font-weight: bold;">istringstream</span> <span style="color: #7fffd4; font-weight: bold;">stream</span>(line);            <span style="color: #add8e6;">// </span><span style="color: #add8e6;">bind to stream to the line we read</span>
  <span style="color: #fa8072;">while</span> (stream &gt;&gt; word){                <span style="color: #add8e6;">// </span><span style="color: #add8e6;">read a word from line</span>
    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">do per-word processing</span>
  }
 }
</pre>
</div>

<p>
One <b><b>common use</b></b> of stringstreams is when we want to <b><b>obtain automatic formatting across multiple</b></b>
<b><b>data types</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">int -&gt; string</span>
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">val1</span> = 512, <span style="color: #7fffd4; font-weight: bold;">val2</span> = 1024;
<span style="color: #9acd32; font-weight: bold;">ostringstream</span> <span style="color: #7fffd4; font-weight: bold;">format_message</span>;
format_message &lt;&lt; <span style="color: #ffa07a;">"val1: "</span> &lt;&lt; val1 &lt;&lt; <span style="color: #ffa07a;">"\n"</span>
&lt;&lt; <span style="color: #ffa07a;">"val2: "</span> &lt;&lt; val2 &lt;&lt; <span style="color: #ffa07a;">"\n"</span>;

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">string -&gt; int</span>
<span style="color: #9acd32; font-weight: bold;">istringstream</span> <span style="color: #7fffd4; font-weight: bold;">input_istring</span>(format_message.str());
<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">dump</span>;
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">extracts the stored ascii values, converting back to arithmetic types</span>
input_istring &gt;&gt; dump &gt;&gt; val1 &gt;&gt; dump &gt;&gt; val2;
cout &lt;&lt; val1 &lt;&lt; <span style="color: #ffa07a;">" "</span> &lt;&lt; val2 &lt;&lt; endl;  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">prints 512 1024</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org456a700" class="outline-2">
<h2 id="org456a700"><span class="section-number-2">8</span> Sequential Containers</h2>
</div>

<div id="outline-container-org580a135" class="outline-2">
<h2 id="org580a135"><span class="section-number-2">9</span> Associative Containers</h2>
<div class="outline-text-2" id="text-9">
<p>
Associative containers support efficient lookup and retrieval by a key. The two primary
associative-container types are <b><b>map</b></b> and <b><b>set</b></b>.
</p>

<p>
The elements in a map are <b><b>key-value</b></b> pairs. A map is most useful when we wish to store (and
modify) a value associated with each key.
</p>

<p>
A set contains only a key and supports efficient queries to whether a given key is present.
</p>

<p>
An object of the map or set type may contain only a single element with a given key. We can use
multipmap or multiset, if we need to have multiple instance with a single key.
</p>
</div>

<div id="outline-container-orgafb0f9f" class="outline-4">
<h4 id="orgafb0f9f"><span class="section-number-4">9.0.1</span> Preliminaries: the pair Type</h4>
<div class="outline-text-4" id="text-9-0-1">
<p>
The simple companion library type <b><b>pair</b></b> is defined in the <b><b>utility</b></b> header.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">pair</span>&lt;T1, T2&gt; <span style="color: #7fffd4; font-weight: bold;">p1</span>;        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Create an empty pair with two elements of types T1 and T2.</span>
<span style="color: #9acd32; font-weight: bold;">pair</span>&lt;T1, T2&gt; <span style="color: #7fffd4; font-weight: bold;">p1</span>(v1, v2);
make_pair(v1, v2);      <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Create a new pair from the values v1 and v2.</span>
p1 == p2
  p.first
  p.second

  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Example</span>
  <span style="color: #fa8072;">typedef</span> <span style="color: #9acd32; font-weight: bold;">pair</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">string</span>&gt; Author;
<span style="color: #9acd32; font-weight: bold;">Author</span> <span style="color: #7fffd4; font-weight: bold;">proust</span>(<span style="color: #ffa07a;">"Marcel"</span>, <span style="color: #ffa07a;">"Proust"</span>);
<span style="color: #9acd32; font-weight: bold;">Author</span> <span style="color: #7fffd4; font-weight: bold;">joyce</span>(<span style="color: #ffa07a;">"James"</span>, <span style="color: #ffa07a;">"Joyce"</span>);

<span style="color: #9acd32; font-weight: bold;">pair</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">string</span>&gt; <span style="color: #7fffd4; font-weight: bold;">next_auth</span>;
<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">first</span>, <span style="color: #7fffd4; font-weight: bold;">last</span>;
<span style="color: #fa8072;">while</span> (cin &gt;&gt; first &gt;&gt; last) {
  next_auth = make_pair (first, last);
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-org17361da" class="outline-3">
<h3 id="org17361da"><span class="section-number-3">9.1</span> Associative Containers</h3>
<div class="outline-text-3" id="text-9-1">
<p>
<b><b>Elements are ordered by key!</b></b> When we <b><b>iterate across</b></b> an associative container, we are guaranteed
that the <b><b>elements</b></b> are <b><b>accessed in a key order</b></b>, irrespective of the order in which the elements
were placed in the container.
</p>
</div>

<div id="outline-container-orga595651" class="outline-4">
<h4 id="orga595651"><span class="section-number-4">9.1.1</span> The map Type</h4>
<div class="outline-text-4" id="text-9-1-1">
<p>
To use a map, we must <b><b>include the map header</b></b>.
</p>
</div>

<div id="outline-container-orgf31d43d" class="outline-5">
<h5 id="orgf31d43d"><span class="section-number-5">9.1.1.1</span> Defining a map</h5>
<div class="outline-text-5" id="text-9-1-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">map</span>&lt;k, v&gt; <span style="color: #7fffd4; font-weight: bold;">m</span>;
<span style="color: #9acd32; font-weight: bold;">map</span>&lt;k, v&gt; <span style="color: #7fffd4; font-weight: bold;">m</span>(m2);      <span style="color: #add8e6;">// </span><span style="color: #add8e6;">create m as a copy of m2</span>
<span style="color: #9acd32; font-weight: bold;">map</span>&lt;k, v&gt; <span style="color: #7fffd4; font-weight: bold;">m</span>(b, e);
</pre>
</div>

<p>
In practice it is <b><b>important</b></b> that the <b><b>key type must define the</b></b> &lt; <b><b>operator</b></b>. There is no
requirement that it support the other relational or equality operators.
</p>
</div>
</div>

<div id="outline-container-org66b015c" class="outline-5">
<h5 id="org66b015c"><span class="section-number-5">9.1.1.2</span> Types Defined by map</h5>
<div class="outline-text-5" id="text-9-1-1-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">map</span>&lt;K, V&gt;::key_type     <span style="color: #add8e6;">// </span><span style="color: #add8e6;">The type of the keys</span>
<span style="color: #7fffd4;">map</span>&lt;K, V&gt;::<span style="color: #9acd32; font-weight: bold;">mapped_type</span>  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">The type of the value</span>
<span style="color: #7fffd4;">map</span>&lt;K, v&gt;::<span style="color: #7fffd4; font-weight: bold;">value_type</span>   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">a pair whose first element is const</span>
</pre>
</div>

<p>
Remember that the <b><b>value<sub>type</sub></b></b> is a <b><b>pair</b></b> and we <b><b>can not change</b></b> the <b><b>key</b></b> member of the pair.
</p>
</div>
</div>

<div id="outline-container-org34ec5b5" class="outline-5">
<h5 id="org34ec5b5"><span class="section-number-5">9.1.1.3</span> Subscripting a map</h5>
<div class="outline-text-5" id="text-9-1-1-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">map</span> &lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">int</span>&gt; <span style="color: #7fffd4; font-weight: bold;">word_count</span>;  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">empty map</span>
word_count[<span style="color: #ffa07a;">"Anna"</span>] = 1;
</pre>
</div>

<p>
The following steps take place:
</p>
<ol class="org-ol">
<li>word<sub>count</sub> is searched for the element whose key is Anna. The element is not found.</li>
<li>A new key-value pair is inserted into word<sub>count</sub>. The key is a const string holding
Anna. The value is initialized, meaning in this case that the value is 0.</li>
<li>The new key-value pair is inserted into word<sub>count</sub>.</li>
<li>The newly inserted element is fetched and is given that value 1.</li>
</ol>

<p>
The fact that subscript adds an element if it is not already in the map allows us to write
<b><b>surprisingly</b></b> <b><b>succinct</b></b> <b><b>programs</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">count number of times each word occurs in the input</span>
<span style="color: #9acd32; font-weight: bold;">map</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">int</span>&gt; <span style="color: #7fffd4; font-weight: bold;">word_count</span>;
<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">word</span>;
<span style="color: #fa8072;">while</span> (cin &gt;&gt; word)
  ++word_count[word];
</pre>
</div>

<p>
注意: 代码 word<sub>count</sub>["Anna"] 有副作用, 如果 word<sub>count</sub> 不存在 "Anna" 这个条目, 便会自动加上此条
目, 并且使用默认值初始化此条目的 value. 如果要获取 map 里某条目的值, 或者判断是否存在某个条目, 应
该使用后面讲述的 count 和 find 命令.
</p>
</div>
</div>

<div id="outline-container-org7d461a0" class="outline-5">
<h5 id="org7d461a0"><span class="section-number-5">9.1.1.4</span> Using map::insert</h5>
<div class="outline-text-5" id="text-9-1-1-4">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">syntax:</span>
m.insert(e)
</pre>
</div>

<p>
e is a value of the value<sub>type</sub> for m. It the key(e.first) is not in m, insert a new element with
value e.second. <b><b>If the key is in m, then m is unchanged</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++">word_count.insert(map&lt;string, <span style="color: #9acd32; font-weight: bold;">int</span>&gt;::value_type(<span style="color: #ffa07a;">"Anna"</span>, 1);
                  word_count.insert(make_pair(<span style="color: #ffa07a;">"Anna"</span>, 1));
</pre>
</div>
</div>
</div>

<div id="outline-container-org2373eb9" class="outline-5">
<h5 id="org2373eb9"><span class="section-number-5">9.1.1.5</span> Finding and Retrieving a map Element</h5>
<div class="outline-text-5" id="text-9-1-1-5">
<p>
Using subscript operator:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">map</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">int</span>&gt; <span style="color: #7fffd4; font-weight: bold;">word_count</span>;
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">occurs</span> = word_count[<span style="color: #ffa07a;">"foobar"</span>];
</pre>
</div>

<p>
Using a <b><b>subscript</b></b> has <b>an important side effect</b>: If that key is <b><b>not</b></b> already <b><b>in the map</b></b>, then
subscript <b><b>inserts an element</b></b> with that key. In this case, occurs gets a value of 0, if "foobar"
were not already present.
</p>

<p>
There are two operations, <b><b>count</b></b> and <b><b>find</b></b>, that we can use to determine if a key is present
without causing it to be inserted.
</p>

<div class="org-src-container">
<pre class="src src-c++">m.count(k)   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Returns the number of occurrences of k within m.</span>
m.find(k)    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Returns an iterator to the element indexed by k, if there is one, or return an</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">off-the-end iterator if the key is not present.</span>
</pre>
</div>

<p>
The count member for a map always returns either 0 or 1, because a map may have only one
instance of any given key. The return from <b><b>count</b></b> is more useful for multimaps.
</p>

<p>
If we want to use the element if it is present, we should use find:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">occurs</span> = 0;
<span style="color: #7fffd4;">map</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">iterator</span> <span style="color: #7fffd4; font-weight: bold;">it</span> = word_count.find(<span style="color: #ffa07a;">"foobar"</span>);
<span style="color: #fa8072;">if</span> (it != word_count.end())
  occurs = it-&gt;second;
</pre>
</div>
</div>
</div>

<div id="outline-container-org98ff5ca" class="outline-5">
<h5 id="org98ff5ca"><span class="section-number-5">9.1.1.6</span> Erasing Elements from a map</h5>
<div class="outline-text-5" id="text-9-1-1-6">
<div class="org-src-container">
<pre class="src src-c++">m.erase(k)     <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Removes the element with key k from m. Return size_type indicating the number</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">of elements removed.</span>
m.erase(p)     <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Removes element referred to by the iterator p from m. Returns void.</span>
m.erase(b, e)  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Removes the elements in the range denoted by the iterator pair b, e.</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">Returns void.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee47140" class="outline-5">
<h5 id="orgee47140"><span class="section-number-5">9.1.1.7</span> Iterating across a map</h5>
<div class="outline-text-5" id="text-9-1-1-7">
<p>
Like any other container, map provides begin and end operations.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">map</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">const_iterator</span> <span style="color: #7fffd4; font-weight: bold;">map_it</span> = word_count.begin();

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">for each element in the map</span>
<span style="color: #fa8072;">while</span> (map_it != word_count.end()) {
  cout &lt;&lt; map_it-&gt;first &lt;&lt; <span style="color: #ffa07a;">" occurs "</span>
       &lt;&lt; map_it-&gt;second &lt;&lt; <span style="color: #ffa07a;">" times "</span> &lt;&lt; endl;
  ++map_it;
 }
</pre>
</div>

<p>
这里的 const<sub>iterator</sub> 和 iterator 的区别在于, 使用 const<sub>iterator</sub> 得到的指针只能读取, 不能修改
container.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb6e80df" class="outline-4">
<h4 id="orgb6e80df"><span class="section-number-4">9.1.2</span> The set Type</h4>
<div class="outline-text-4" id="text-9-1-2">
<p>
&lt;example&gt;
Constructors    default methods to allocate, copy, and deallocate sets
Operators       assign and compare sets
</p>

<p>
begin           returns an iterator to the beginning of the set
clear           removes all elements from the set
count           returns the number of elements matching a certain key
empty           true if the set has no elements
end             returns an iterator just past the last element of a set
equal<sub>range</sub>     returns iterators to the first and just past the last elements matching a specific key
erase           removes elements from a set
find            returns an iterator to specific elements
insert          insert items into a set
key<sub>comp</sub>        returns the function that compares keys
lower<sub>bound</sub>     returns an iterator to the first element greater than or equal to a certain value
max<sub>size</sub>        returns the maximum number of elements that the set can hold
rbegin          returns a reverse<sub>iterator</sub> to the end of the set
rend            returns a reverse<sub>iterator</sub> to the beginning of the set
size            returns the number of items in the set
swap            swap the contents of this set with another
upper<sub>bound</sub>     returns an iterator to the first element greater than a certain value
value<sub>comp</sub>      returns the function that compares values
&lt;/example&gt;
</p>
</div>

<div id="outline-container-org10fd1d5" class="outline-5">
<h5 id="org10fd1d5"><span class="section-number-5">9.1.2.1</span> Defining and Using sets</h5>
<div class="outline-text-5" id="text-9-1-2-1">
<p>
As with map, there can be only one element with a given key in a set. When we initialize a set
from a range of elements or insert a range of elements, only one element with a given key is
actually added:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt; <span style="color: #7fffd4; font-weight: bold;">ivec</span>;
<span style="color: #fa8072;">for</span> (<span style="color: #7fffd4;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt;::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">i</span> = 0; i != 10; ++i) {
  ivec.push_back(i);
  ivec.push_back(i);    <span style="color: #add8e6;">//</span><span style="color: #add8e6;">duplicate copies of each number</span>
 }

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">iset holds unique elements from ivec</span>
<span style="color: #9acd32; font-weight: bold;">set</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt; <span style="color: #7fffd4; font-weight: bold;">iset</span>(ivec.begin(), ivec.end());
count &lt;&lt; ivec.size() &lt;&lt; endl;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">prints 20</span>
count &lt;&lt; iset.size() &lt;&lt; endl;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">prints 10</span>
</pre>
</div>

<p>
We can add elements to a set by using the <b><b>insert</b></b> operation:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">set</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>&gt; <span style="color: #7fffd4; font-weight: bold;">set1</span>;         <span style="color: #add8e6;">// </span><span style="color: #add8e6;">empty set</span>
set1.insert(<span style="color: #ffa07a;">"the"</span>);       <span style="color: #add8e6;">// </span><span style="color: #add8e6;">has one element</span>
set1.insert(ivec.begin(), ivec.end());
</pre>
</div>

<p>
iterate a set:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">set</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>&gt;::<span style="color: #9acd32; font-weight: bold;">const_iterator</span> <span style="color: #7fffd4; font-weight: bold;">loc_iter</span> = text_locs.begin(),
  <span style="color: #7fffd4; font-weight: bold;">loc_iter_end</span> = text_locs.end();
<span style="color: #fa8072;">while</span> (loc_iter != loc_iter_end) {
  cout &lt;&lt; *loc_iter;
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-org4a1a9d9" class="outline-5">
<h5 id="org4a1a9d9"><span class="section-number-5">9.1.2.2</span> Fetching an Element from a set</h5>
<div class="outline-text-5" id="text-9-1-2-2">
<div class="org-src-container">
<pre class="src src-c++">iset.find(1)         <span style="color: #add8e6;">// </span><span style="color: #add8e6;">returns iterator that refers to the element with key == 1</span>
iset.find(11)        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">returns iterator == iset.end()</span>
iset.count(1)        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">returns 1</span>
iset.count(11)       <span style="color: #add8e6;">// </span><span style="color: #add8e6;">returns 0</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2da4d55" class="outline-4">
<h4 id="org2da4d55"><span class="section-number-4">9.1.3</span> multimap and multiset Types</h4>
<div class="outline-text-4" id="text-9-1-3">
<p>
The types multiset and a multimap allow multiple instances of a key. The operations supported by
multimap and multiset are the same as those on map and set, respectively, with on exception:
multimap does not support subscripting. Because there may be more than one value associated with
a given key.
</p>
</div>

<div id="outline-container-orge5916cf" class="outline-5">
<h5 id="orge5916cf"><span class="section-number-5">9.1.3.1</span> Adding and Removing Elements</h5>
<div class="outline-text-5" id="text-9-1-3-1">
<p>
Because keys need not be unique, insert always adds an element.
</p>

<div class="org-src-container">
<pre class="src src-c++">authors.insert(make_pair(
                         string(<span style="color: #ffa07a;">"Barth, John"</span>),
                         string(<span style="color: #ffa07a;">"Sct-Weed Factor"</span>)));
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">OK: adds second element with key Barth</span>
authors.insert(make_pair(
                         string(<span style="color: #ffa07a;">"Barth, John"</span>),
                         string(<span style="color: #ffa07a;">"Lost in the Funhouse"</span>)));
</pre>
</div>

<p>
The version of erase that takes a key removes all elements with that key. It returns a count of
how many elements were removed. The versions that take an iterator or an iterator pair remove
only the indicated element(s). These versions return void.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">multimap</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">string</span>&gt; <span style="color: #7fffd4; font-weight: bold;">authors</span>;
<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">search_item</span>(<span style="color: #ffa07a;">"Barth, John"</span>);
<span style="color: #7fffd4;">multimap</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">string</span>&gt;::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #7fffd4; font-weight: bold;">cnt</span> = authors.erase(search_item);
</pre>
</div>
</div>
</div>

<div id="outline-container-org557e809" class="outline-5">
<h5 id="org557e809"><span class="section-number-5">9.1.3.2</span> Finding Elements in a multimap or multiset</h5>
<div class="outline-text-5" id="text-9-1-3-2">
<p>
Like map ans set, the multimap and multiset store their elements in order.
</p>

<ul class="org-ul">
<li>Using find and count</li>
</ul>

<p>
The count function tells us how many times a given key occurs, and the find operation returns a
iterator that refers to the first instance of the key we are looking for.
</p>

<ul class="org-ul">
<li>Iterator-Oriented Solution</li>
</ul>

<p>
Another, more elegant strategy uses two associative container operations: <b><b>lower<sub>bound</sub></b></b> and
<b><b>upper<sub>bound</sub></b></b>.
</p>

<p>
If the key <b><b>is in the container</b></b>, the iterators will differ: the one returned from lower<sub>bound</sub>
will refer to the first instance of the key, whereas upper<sub>bound</sub> will return an iterator
referring just after the last instance.
</p>

<p>
If the key is not in the container, then lower<sub>bound</sub> and upper<sub>bound</sub> will return equal
iterators. Both will refer to the point at which the key could be inserted without disrupting
the order.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">typedef</span> <span style="color: #7fffd4;">multimap</span>&lt;<span style="color: #9acd32; font-weight: bold;">string</span>, <span style="color: #9acd32; font-weight: bold;">string</span>&gt;::<span style="color: #9acd32; font-weight: bold;">iterator</span> <span style="color: #9acd32; font-weight: bold;">authors_it</span>;
<span style="color: #9acd32; font-weight: bold;">authors_it</span> <span style="color: #7fffd4; font-weight: bold;">beg</span> = authors.lower_bound(serach_iterm);
end = authors.upper_bound(search_iterm);
<span style="color: #fa8072;">while</span> ( beg != end ) {
  cout &lt;&lt; beg-&gt;second &lt;&lt; endl;
  ++beg;
 }
</pre>
</div>

<p>
These operations say nothing about whether the key is present. The important point is that the
return values act like an iterator range.
</p>

<ul class="org-ul">
<li>The equal<sub>range</sub> Function</li>
</ul>

<p>
Function <b><b>equal<sub>range</sub></b></b> returns a <b><b>pair of iterators</b></b>. The first member is equivalent to
m.lower<sub>bound</sub>(search<sub>item</sub>), and second is equivalent to m.upper<sub>bound</sub>(search<sub>item</sub>).
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">pair</span>&lt;authors_it, authors_it&gt; <span style="color: #7fffd4; font-weight: bold;">pos</span> = authors.equal_range(search_item);
<span style="color: #fa8072;">while</span> (pos.first != pos.second) {
  cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;
  ++pos.first;
 }
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org338a30b" class="outline-2">
<h2 id="org338a30b"><span class="section-number-2">10</span> Classes</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org26a49b6" class="outline-3">
<h3 id="org26a49b6"><span class="section-number-3">10.1</span> Class Definitions and Declarations</h3>
<div class="outline-text-3" id="text-10-1">
</div>
<div id="outline-container-orgb64d35a" class="outline-4">
<h4 id="orgb64d35a"><span class="section-number-4">10.1.1</span> Defining Objects of Class Type</h4>
<div class="outline-text-4" id="text-10-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">Sales_item</span> <span style="color: #7fffd4; font-weight: bold;">item1</span>;
<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> <span style="color: #7fffd4; font-weight: bold;">item1</span>;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">equivalent definition of item1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9addefe" class="outline-4">
<h4 id="org9addefe"><span class="section-number-4">10.1.2</span> Why a Class Definition Ends in a Semicolon</h4>
<div class="outline-text-4" id="text-10-1-2">
<p>
A semicolon is required because we can follow a class definition by a list of object
definitions. But it is a bad idea to define an object as part of a class definition.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> };
<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> } <span style="color: #7fffd4; font-weight: bold;">accum</span>, <span style="color: #7fffd4; font-weight: bold;">trans</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8219e4" class="outline-4">
<h4 id="orga8219e4"><span class="section-number-4">10.1.3</span> The Implicit 'this' Pointer</h4>
<div class="outline-text-4" id="text-10-1-3">
<p>
There is one case in which we must refer explicitly to 'this' inside a member function: when we
need to refer to the object as a whole rather than to a member of the object. The most common
case where we must use 'this' is in functions that return a reference to the object on which
they were invoked.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">Screen</span>&amp; <span style="color: #7fffd4;">Screen</span>::<span style="color: #7fffd4; font-weight: bold;">set</span> (<span style="color: #9acd32; font-weight: bold;">char</span> <span style="color: #7fffd4; font-weight: bold;">c</span>) {
  <span style="color: #add8e6;">//</span><span style="color: #add8e6;">...</span>
  <span style="color: #fa8072;">return</span> *<span style="color: #fa8072;">this</span>;
}
<span style="color: #9acd32; font-weight: bold;">Screen</span>&amp; <span style="color: #7fffd4;">Screen</span>::<span style="color: #7fffd4; font-weight: bold;">move</span> (<span style="color: #9acd32; font-weight: bold;">index</span> <span style="color: #7fffd4; font-weight: bold;">r</span>, <span style="color: #9acd32; font-weight: bold;">index</span> <span style="color: #7fffd4; font-weight: bold;">c</span>) {
  <span style="color: #add8e6;">//</span><span style="color: #add8e6;">...</span>
  <span style="color: #fa8072;">return</span> *<span style="color: #fa8072;">this</span>;
}

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">each operation returns a reference to the object on which it executes,</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">then we can concatenate a sequence of actions into a single expression:</span>
myScreen.move(4, 0).set(<span style="color: #ffa07a;">'#'</span>);

<span style="color: #add8e6;">// </span><span style="color: #add8e6;">equivalent to</span>
myScreen.move(4, 0);
myScreen.set(<span style="color: #ffa07a;">'#'</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org43bf1ac" class="outline-4">
<h4 id="org43bf1ac"><span class="section-number-4">10.1.4</span> Mutable Data Members</h4>
<div class="outline-text-4" id="text-10-1-4">
<p>
A <b><b>mutable data member</b></b> is a member that is never const, even when it is a member of a const
object. So we can modify it, even inside a const member function. To declare a data member as
mutable, the keyword mutable must precede the declaration of the member:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Screen</span> {
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
  <span style="color: #fa8072;">mutable</span> <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">access_ctr</span>;  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">may change in a const members</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org6bfb2ee" class="outline-4">
<h4 id="org6bfb2ee"><span class="section-number-4">10.1.5</span> Scope and Member Definitions</h4>
<div class="outline-text-4" id="text-10-1-5">
<p>
Member definitions that appear outside the class body must indicate the class in which the
member appears.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4;">Sales_item</span>::<span style="color: #7fffd4; font-weight: bold;">avg_price</span>() <span style="color: #fa8072;">const</span> {
  <span style="color: #fa8072;">if</span> (units_sold)
    <span style="color: #fa8072;">return</span> revenue/units_sold;
  <span style="color: #fa8072;">else</span>
    <span style="color: #fa8072;">return</span> 0;
}
</pre>
</div>

<p>
Here we use the fully qualified name 'Sales<sub>item</sub>:.avg<sub>price</sub>' to indicate that the definition is
for the 'avg<sub>price</sub>' member in the scope of the 'Sales<sub>item</sub>' class. <b><b>Once the fully qualified name</b></b>
<b><b>of the member is seen, the definition is known to be in class scope</b></b>. Then we can refer to
'revenue' and 'units<sub>sold</sub>' directly.
</p>
</div>
</div>

<div id="outline-container-org05a0711" class="outline-4">
<h4 id="org05a0711"><span class="section-number-4">10.1.6</span> Function Return Types Aren't Always in Class Scope</h4>
<div class="outline-text-4" id="text-10-1-6">
<p>
If the <b><b>function</b></b> is defined <b><b>outside the class body</b></b>, then the name used for the return type is
outside the class scope. If the <b><b>return type</b></b> uses a type <b><b>defined by the class</b></b>, it <b><b>must</b></b> use the
<b><b>fully qualified name</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Screen</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #fa8072;">typedef</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">string</span>::<span style="color: #9acd32; font-weight: bold;">size_type</span> <span style="color: #9acd32; font-weight: bold;">index</span>;
  <span style="color: #9acd32; font-weight: bold;">index</span> <span style="color: #7fffd4; font-weight: bold;">get_cursor</span>() <span style="color: #fa8072;">const</span>;
};
<span style="color: #fa8072;">inline</span> <span style="color: #7fffd4;">Screen</span>::<span style="color: #9acd32; font-weight: bold;">index</span> <span style="color: #7fffd4;">Screen</span>::<span style="color: #7fffd4; font-weight: bold;">get_cursor</span>() <span style="color: #fa8072;">const</span> {
  <span style="color: #fa8072;">return</span> cursor;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9242b79" class="outline-3">
<h3 id="org9242b79"><span class="section-number-3">10.2</span> Constructors</h3>
<div class="outline-text-3" id="text-10-2">
</div>
<div id="outline-container-orgaaec681" class="outline-4">
<h4 id="orgaaec681"><span class="section-number-4">10.2.1</span> Constructor Initializer</h4>
<div class="outline-text-4" id="text-10-2-1">
<p>
Unlike other functions, a constructor may contain a constructor initializer list.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">recommended way to write constructors using a constructor initializer</span>
<span style="color: #7fffd4;">Sales_item</span>::<span style="color: #7fffd4; font-weight: bold;">Sales_item</span>(<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">book</span>):
  isbn (book), units_sold(0), revenue(0.0) {}
</pre>
</div>

<p>
It is usually legal to omit the initializer list and assign values to the data members inside
the constructor body. For example:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">legal but sloppier way to write the constructor: no constructor initializer</span>
<span style="color: #7fffd4;">Sales_item</span>::<span style="color: #7fffd4; font-weight: bold;">Sales_item</span>(<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">book</span>) {
  isbn = book;
  units_sold = 0;
  revenue = 0.0;
}
</pre>
</div>

<p>
Regardless of the lack of an explicit initializer, the isbn member is <b><b>initialized before</b></b> the
<b><b>constructor</b></b> is <b><b>executed</b></b>. This constructor <b><b>implicitly</b></b> uses the default string constructor to
<b><b>initialize</b></b> isbn. When the body of the constructor is executed, the isbn member already has a
value. That value is overwritten by the assignment inside the constructor body. That value is
<b><b>overwritten</b></b> by the assignment inside the constructor body.
</p>

<p>
Conceptually, we can think of a constructor as executing in two phases:
</p>
<ol class="org-ol">
<li>the initialization phase</li>
<li>a general computation phase (consists of all the statements within the body of the
constructor)</li>
</ol>

<p>
Each member that is not explicitly mentioned in the constructor initializer is initialized using
the same rules as those used to initialize variables.
</p>
</div>
</div>

<div id="outline-container-org8239282" class="outline-4">
<h4 id="org8239282"><span class="section-number-4">10.2.2</span> Constructor Initializers Are Sometimes Required</h4>
<div class="outline-text-4" id="text-10-2-2">
<p>
With two exceptions, using a initializer is equivalent to assigning to a nonclass data member
both in result and in performance.
</p>

<p>
For example, the following constructor is in error:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">ConstRef</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #7fffd4; font-weight: bold;">ConstRef</span>(<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ii</span>);
<span style="color: #fa8072;">private</span>:
  <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span>;
  <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ci</span>;
  <span style="color: #9acd32; font-weight: bold;">int</span> &amp;<span style="color: #7fffd4; font-weight: bold;">ri</span>;
};
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">no explicit constructor initializer: error ri is uninitialized</span>
<span style="color: #7fffd4;">ConstRef</span>::<span style="color: #7fffd4; font-weight: bold;">ConstRef</span>(<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ii</span>) {
  i = ii;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok</span>
  ci = ii;  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: cannot assign to a const</span>
  ri = i;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">assigns to ri which was not bound to an object</span>
}
</pre>
</div>

<p>
Remember that we <b><b>can initialize but not assign</b></b> to <b><b>const objects</b></b> or <b><b>objects of reference</b></b>
<b><b>type</b></b>. Our only chance to initialize const or reference data members is in the constructor
initializer:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #7fffd4;">ConstRef</span>::<span style="color: #7fffd4; font-weight: bold;">ConstRef</span>(<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">ii</span>): i(ii), ci(i), ri(ii) {}
</pre>
</div>

<p>
<b>Note</b>: We <b><b>must</b></b> use an <b><b>initializer</b></b> for any <b><b>const</b></b> or <b><b>reference member</b></b> or for any member of a <b><b>class</b></b>
<b><b>type</b></b> that does <b><b>not</b></b> have a <b><b>default constructor</b></b>.
</p>
</div>
</div>

<div id="outline-container-org3adb28c" class="outline-4">
<h4 id="org3adb28c"><span class="section-number-4">10.2.3</span> The Default Constructor</h4>
<div class="outline-text-4" id="text-10-2-3">
<p>
The compiler generates a default constructor (<b><b>synthesized default constructor</b></b>) automatically
<b><b>only if</b></b> a class defines <b><b>no constructors</b></b>.
</p>

<p>
The synthesized default constructor initializes members using the same rules as those that apply
for how variables are initialized. <b><b>Members of built-in or compound type</b></b>, such as pointers and
arrays, are <b><b>not initialized</b></b> for objects that are <b><b>defined at local scope</b></b>. If a class contains
data members of built-in or compound type, then the class should not rely on the synthesized
default constructor.
</p>

<p>
Furthermore, it is almost always right to provide a default constructors if other constructors
are being defined. Ordinarily the initial values given to the members in the default constructor
should indicate that the object is "empty".
</p>
</div>
</div>

<div id="outline-container-org64aa326" class="outline-4">
<h4 id="org64aa326"><span class="section-number-4">10.2.4</span> Implicit Class-Type Conversions</h4>
<div class="outline-text-4" id="text-10-2-4">
<p>
A <b><b>constructor</b></b> that can be <b><b>called with a single argument</b></b> defines an <b>implicit conversion</b> from the
parameter type to the class type.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #7fffd4; font-weight: bold;">Sales_item</span> (<span style="color: #fa8072;">const</span> <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">book</span> = <span style="color: #ffa07a;">""</span>):
    isbn (book), units_sold(0), revenue(0.0) {}
  <span style="color: #add8e6;">//</span><span style="color: #add8e6;">...</span>
};
</pre>
</div>

<p>
This constructor defines an implicit conversion.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">null_book</span> = <span style="color: #ffa07a;">"9-99999-999-9"</span>;
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">The function expects a Sales_item object as its argument</span>
item.same_isbn(null_book);
</pre>
</div>

<p>
The compiler uses the Sales<sub>item</sub> constructor that takes a string to generate a new Sales<sub>item</sub>
object from null<sub>book</sub>, und passes the newly generated object to same<sub>isbn</sub>.
</p>

<p>
We can <b><b>prevent</b></b> the use of a constructor in a context that requires an implicit conversion by
declaring the constructor <b>explicit</b>. The explicit keyword is used only on the constructor
declaration inside the class.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #fa8072;">explicit</span> <span style="color: #7fffd4; font-weight: bold;">Sales_item</span> (<span style="color: #fa8072;">const</span> <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">string</span> &amp;<span style="color: #7fffd4; font-weight: bold;">book</span> = <span style="color: #ffa07a;">""</span>):
    isbn (book), units_sold(0), revenue(0.0) {}
  <span style="color: #add8e6;">//</span><span style="color: #add8e6;">...</span>
};

item.same_isbn(null_book);    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: string constructor is explicit</span>
item.same_isbn(Sales_item(null_book));  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">ok: explicitly create a temporary obj</span>
</pre>
</div>

<p>
<b>Best Practices</b>: Ordinarily, <b><b>single-parameter constructors should be explicit</b></b> unless there is an
obvious reason to want to define an implicit conversion. Making constructors explicit may <b><b>avoid</b></b>
<b><b>mistakes</b></b>, and a user can explicitly construct an object when a conversion is useful.
</p>
</div>
</div>
</div>

<div id="outline-container-org6fbe162" class="outline-3">
<h3 id="org6fbe162"><span class="section-number-3">10.3</span> Friends</h3>
<div class="outline-text-3" id="text-10-3">
<p>
The <b><b>friend mechanism</b></b> allows a class to grant <b><b>access</b></b> to tis <b><b>nonpublic members</b></b> to specified
functions or classes. A friend declaration begings with the keyword friend. It may appear only
within a class definition. Friend declarations <b><b>may appear anywhere</b></b> in the class, but it is a
<b><b>good idea</b></b> to <b><b>group</b></b> friend declarations <b><b>together</b></b> either at the beginning or end of the class
definition.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Screen</span> {
  <span style="color: #fa8072;">friend</span> <span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Window_Mgr</span>;
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
}
</pre>
</div>

<p>
Instead of making the entire Window<sub>Mgr</sub> class a friend, Screen could have specified that only
the relocate member was allowed access:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Screen</span> {
  <span style="color: #fa8072;">friend</span> <span style="color: #9acd32; font-weight: bold;">Window_Mgr</span>&amp;
  <span style="color: #7fffd4;">Window_Mgr</span>::<span style="color: #7fffd4; font-weight: bold;">relocate</span>(<span style="color: #7fffd4;">Window_Mgr</span>::index, <span style="color: #7fffd4;">Window_Mgr</span>::index, <span style="color: #9acd32; font-weight: bold;">Screen</span>&amp;);
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
}
</pre>
</div>

<p>
Class names and functions (definitions or declarations) <b><b>introduced in a friend</b></b> can be used <b><b>as if</b></b>
they had <b><b>been previouly declared</b></b>.
</p>
</div>
</div>

<div id="outline-container-orga2104f5" class="outline-3">
<h3 id="orga2104f5"><span class="section-number-3">10.4</span> static Class Members</h3>
<div class="outline-text-3" id="text-10-4">
<p>
<b><b>A static data member</b></b> exists independentyly of any object of its class, each <b><b>static data member</b></b>
is an object <b><b>associated with the class</b></b>, not with the objects of that class.
</p>

<p>
<b><b>A static member function</b></b> has no this parameter. It may <b><b>directly access the static members</b></b> of its
class but may <b><b>not directly use the nonstatic members</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Account</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">interface functions here</span>
  <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">applyint</span>() { amount += amount * interestRate; }
  <span style="color: #fa8072;">static</span> <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">rate</span>() { <span style="color: #fa8072;">return</span> interestRate; }
  <span style="color: #fa8072;">static</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">rate</span>(<span style="color: #9acd32; font-weight: bold;">double</span>); <span style="color: #add8e6;">// </span><span style="color: #add8e6;">sets a new rate</span>
<span style="color: #fa8072;">private</span>:
  <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">owner</span>;
  <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">amount</span>;
  <span style="color: #fa8072;">static</span> <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">interestRate</span>;
  <span style="color: #fa8072;">static</span> <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">initRate</span>();
};
</pre>
</div>

<p>
<b><b>Each object</b></b> of this class <b><b>has two data members</b></b>: owner and amount. Objects do not have data
members that correspond to static data members. Instead, there is a <b><b>single</b></b> interestRate <b><b>object</b></b>
that is <b><b>shared by all objects of type Account</b></b>.
</p>

<p>
Using a class static member:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">Account</span> <span style="color: #7fffd4; font-weight: bold;">ac1</span>;
<span style="color: #9acd32; font-weight: bold;">Account</span> *<span style="color: #7fffd4; font-weight: bold;">ac2</span> = &amp;ac1;
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">equivalent ways to call the static member rate function</span>
<span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">rate</span>;
rate = ac1.rate();        <span style="color: #add8e6;">// </span><span style="color: #add8e6;">through an Account object or reference</span>
rate = ac2-&gt;rate();       <span style="color: #add8e6;">// </span><span style="color: #add8e6;">through a pointer to an Account object</span>
rate = <span style="color: #7fffd4;">Account</span>::rate();   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">directly from the class using the scope operator</span>
</pre>
</div>

<p>
Because a static member is not part of any object, static member functions <b><b>may not be declared</b></b>
<b><b>as const</b></b>. After all, declaring a member function as const is a <b><b>promise</b></b> not to modify the object
of which the function is a member.
</p>
</div>

<div id="outline-container-org29c611b" class="outline-4">
<h4 id="org29c611b"><span class="section-number-4">10.4.1</span> static Data Members</h4>
<div class="outline-text-4" id="text-10-4-1">
<p>
static data members can be declared to be of any type, eg consts. They <b>must</b> be <b><b>defined</b></b> (<b>exactly</b>
<b>once</b>) <b><b>outside the class body</b></b>. Unlike ordinary data members, static members are not intialized
through the class constructor(s) and instead should be intialized when they are defined. The
best way to ensure that the object is defined exactly once is to put the definition of static
data members in the same file that contains the definitions of the class noninline member
functions.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">define and initialize static class member</span>
<span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4;">Account</span>::<span style="color: #7fffd4; font-weight: bold;">interestRate</span> = initRate();
</pre>
</div>

<p>
The <b><b>definition</b></b> of a static member is <b><b>in class scope</b></b> once the member name is seen. As a result,
we can use the static member function named 'iniRate' <b><b>directly without qualification</b></b> as the
<b><b>initializer</b></b> for 'interestRate'. And even though 'initRate' is <b><b>private</b></b>, we <b><b>can use this</b></b> function
to initialize 'interestRate'.
</p>

<p>
中文解释: 静态数据成员 'interestRate' 的定义是在它的类的域内, 当限定修饰名 Account::interestRate
被看到之后, 它就可以不加修饰名地引用 Account 的私有函数. 注意, 这里说 '在它的类的域(scope)内', 不
要和 '在类体(body)内' 混淆. 静态数据成员的 definition 必须在 类体 之外.
</p>
</div>
</div>

<div id="outline-container-orgbd60fd4" class="outline-4">
<h4 id="orgbd60fd4"><span class="section-number-4">10.4.2</span> Integral const static Members Are Special</h4>
<div class="outline-text-4" id="text-10-4-2">
<p>
static data members are normally initialized when they are defined. One <b><b>exception</b></b> to this rule
is that a const static data member of integral type can be initialized within the class body as
long as the initializer is a constant expression.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Account</span> {
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
  <span style="color: #fa8072;">static</span> <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">period</span> = 30;
};

<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4;">Account</span>::<span style="color: #7fffd4; font-weight: bold;">period</span>;
</pre>
</div>

<p>
When a const static data member is initialized in the class body, the data member must still be
defined outside the class definition. But the definition must not specify an initial value.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org37cbad4" class="outline-2">
<h2 id="org37cbad4"><span class="section-number-2">11</span> Copy Control</h2>
<div class="outline-text-2" id="text-11">
<p>
Copy constructor: the constructor that takes a single parameter that is a (usually const)
<b><b>reference</b></b> to an object of the <b><b>class type itself</b></b>
</p>
</div>

<div id="outline-container-org813e39c" class="outline-4">
<h4 id="org813e39c"><span class="section-number-4">11.0.1</span> The Synthesized Copy Constructor</h4>
<div class="outline-text-4" id="text-11-0-1">
<p>
A copy constructor is synthesized even if we define other constructors. The behavior of the
synthesized copy constructor is to <b><b>memberwise initialize</b></b> the new object as a copy of the
original object.
</p>

<p>
If a class has a member that is an <b><b>array</b></b>, the synthesized copy constructor will copy each
element.
</p>
</div>
</div>
</div>

<div id="outline-container-org9d445e4" class="outline-2">
<h2 id="org9d445e4"><span class="section-number-2">12</span> Object-Oriented Programming</h2>
<div class="outline-text-2" id="text-12">
<p>
Object-oriented programming is based on three fundamental concepts: <b><b>data abstraction</b></b>,
<b><b>inheritance</b></b>, and <b><b>dynamic binding</b></b>.
</p>

<p>
The key idea behind OOP is <b><b>polymorphism</b></b>, which means "many forms".
</p>
</div>

<div id="outline-container-org175d65b" class="outline-3">
<h3 id="org175d65b"><span class="section-number-3">12.1</span> Base Class</h3>
<div class="outline-text-3" id="text-12-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Item_base</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #9acd32; font-weight: bold;">Item_base</span> (...) {}
  <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">book</span>() <span style="color: #fa8072;">const</span> {<span style="color: #fa8072;">return</span> isbn;}
  <span style="color: #fa8072;">virtual</span> <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">net_price</span> (<span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">n</span>) <span style="color: #fa8072;">const</span>
  { <span style="color: #fa8072;">return</span> n * price; }
<span style="color: #fa8072;">private</span>:
  <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">string</span> <span style="color: #7fffd4; font-weight: bold;">isbn</span>;
<span style="color: #fa8072;">protected</span>:
  <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">price</span>;
</pre>
</div>
</div>

<div id="outline-container-orgb31e2d1" class="outline-4">
<h4 id="orgb31e2d1"><span class="section-number-4">12.1.1</span> protected Members</h4>
<div class="outline-text-4" id="text-12-1-1">
<ul class="org-ul">
<li>protected members are inaccessible to users of the class</li>
<li>protected members are accessible to classes derived from this class.</li>
<li>A derived object may access the protected members of this base class <b><b>only</b></b> through a derived
object. The derived class has no special access to the protected members of base type
objects.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb7a09d6" class="outline-3">
<h3 id="orgb7a09d6"><span class="section-number-3">12.2</span> Derived Class</h3>
<div class="outline-text-3" id="text-12-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">classname</span>: <span style="color: #9acd32; font-weight: bold;">access</span>-label base-<span style="color: #fa8072;">class</span>
</pre>
</div>

<p>
Access-label is one of <b><b>public</b></b>, <b><b>protected</b></b>, or <b><b>private</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Bulk_item</span> : <span style="color: #fa8072;">public</span> <span style="color: #9acd32; font-weight: bold;">Item_base</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">net_price</span> (<span style="color: #7fffd4;">std</span>::size_t) <span style="color: #fa8072;">const</span>;
<span style="color: #fa8072;">private</span>:
  <span style="color: #7fffd4;">std</span>::size_t min_qty
  <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">discount</span>;
};
</pre>
</div>

<p>
Once a function is declared as <b><b>virtual</b></b> in a base class it remains virtual; nothing the derived
classes do can change the fact that the function is virtual. When a derived class redefines a
virtual, it may use the virtual keyword, but it is not required to do so.
</p>

<p>
A derived object consists of multiple parts: the members defined in the derived class itself
plus the subobjects made up of the members of its base class.
</p>
</div>
</div>

<div id="outline-container-org94fa5fd" class="outline-3">
<h3 id="org94fa5fd"><span class="section-number-3">12.3</span> virtual</h3>
<div class="outline-text-3" id="text-12-3">
<p>
To trigger dynamic binding, two conditions must be met:
</p>
<ul class="org-ul">
<li>only member functions that are specified as virtual can be dynamically bound.</li>
<li>the call must be made through a reference or a pointer to a base-class type.</li>
</ul>

<p>
A <b><b>base-type</b></b> reference or pointer <b><b>might refer to</b></b> an object of <b><b>base type</b></b> or an object of <b><b>derived</b></b>
<b><b>type</b></b>. Regardless of which actual type the object has, the compiler treats the object as if a
base type object.
</p>
</div>

<div id="outline-container-org59e2ff8" class="outline-5">
<h5 id="org59e2ff8"><span class="section-number-5">12.3.0.1</span> Calls to virtual Functions May Be Resolved at Run time</h5>
<div class="outline-text-5" id="text-12-3-0-1">
<p>
When a virtual function is <b><b>called</b></b> <b><b>through</b></b> <b><b>a</b></b> <b><b>reference</b></b> <b><b>or</b></b> <b><b>pointer</b></b>, the compiler generates code to
<b><b>decide</b></b> <b><b>at</b></b> <b><b>run</b></b> <b><b>time</b></b> which function to call.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">print_toal</span> (<span style="color: #9acd32; font-weight: bold;">ostream</span> &amp;<span style="color: #7fffd4; font-weight: bold;">os</span>, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Item_base</span> &amp;<span style="color: #7fffd4; font-weight: bold;">item</span>, <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">n</span>) {
  os &lt;&lt; item.net_price(n) &lt;&lt; endl;
}
<span style="color: #9acd32; font-weight: bold;">Item_base</span> <span style="color: #7fffd4; font-weight: bold;">base</span>;
<span style="color: #9acd32; font-weight: bold;">Bulk_item</span> <span style="color: #7fffd4; font-weight: bold;">derived</span>;
print_total(cout, base 10)   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">calls Item_base::net_price</span>
print_total(cout, derived, 10) <span style="color: #add8e6;">// </span><span style="color: #add8e6;">calls Bulk_item::net_price</span>
</pre>
</div>

<p>
Virtuals are resolved at run time <b>only</b> if the call is made through a reference or pointer.
</p>
</div>
</div>

<div id="outline-container-orgc4d8d6b" class="outline-5">
<h5 id="orgc4d8d6b"><span class="section-number-5">12.3.0.2</span> Overriding the Virtual Mechanism</h5>
<div class="outline-text-5" id="text-12-3-0-2">
<p>
If we want to override the virtual mechanism and force a call to use a particular version of a
virtual function, we can do so by using the scope operator:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">Item_base</span> *<span style="color: #7fffd4; font-weight: bold;">baseP</span> = &amp;derived;
<span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">d</span> = baseP-&gt;<span style="color: #7fffd4;">Item_base</span>::net_price(32);
</pre>
</div>

<p>
The call will be resolved at compile time.
</p>
</div>
</div>

<div id="outline-container-org0778c50" class="outline-4">
<h4 id="org0778c50"><span class="section-number-4">12.3.1</span> Public, Private and Protected Inheritance</h4>
<div class="outline-text-4" id="text-12-3-1">
<p>
Each class controls access to the members it defines. A derived class may further restrict but
may not loosen the access the members that it inherits.
</p>

<ul class="org-ul">
<li>In public inheritance, the members of the base retain their access levels.</li>
<li>In protected inheritance, the public and protected members of the base class are protected
members in the derived class.</li>
<li>In private inheritance, all the members of the base class are private in the derived class.</li>
</ul>
</div>

<div id="outline-container-org8c40031" class="outline-5">
<h5 id="org8c40031"><span class="section-number-5">12.3.1.1</span> Exempting Individual Members</h5>
<div class="outline-text-5" id="text-12-3-1-1">
<p>
When inheritance is private or protected, the access level of members of the base may be more
restrictive in the derived class than it ware int the base.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Base</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">size</span>() <span style="color: #fa8072;">const</span> { <span style="color: #fa8072;">return</span> n; }
};

<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Derived</span> : <span style="color: #fa8072;">private</span> <span style="color: #9acd32; font-weight: bold;">Base</span> { ... };
</pre>
</div>

<p>
To make size public in Derived we can add a <b><b>using declaration</b></b> for it to a public section in
Derived.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Derived</span> : <span style="color: #fa8072;">private</span> <span style="color: #9acd32; font-weight: bold;">Base</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #fa8072;">using</span> <span style="color: #7fffd4;">Base</span>::<span style="color: #9acd32; font-weight: bold;">size</span>;
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc161c8c" class="outline-4">
<h4 id="orgc161c8c"><span class="section-number-4">12.3.2</span> Friendship and Inheritance</h4>
<div class="outline-text-4" id="text-12-3-2">
<p>
<b><b>Friendship is not inherited</b></b>. Friends of the base have no special access to members of its
derived classes.
</p>
</div>
</div>

<div id="outline-container-org3ac8298" class="outline-4">
<h4 id="org3ac8298"><span class="section-number-4">12.3.3</span> Pure Virtual Functions</h4>
<div class="outline-text-4" id="text-12-3-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Disc_item</span> : <span style="color: #fa8072;">public</span> <span style="color: #9acd32; font-weight: bold;">Item_base</span> { ... }
  <span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Bulk_item</span> : <span style="color: #fa8072;">public</span> <span style="color: #9acd32; font-weight: bold;">Disc_item</span> { ... }
</pre>
</div>

<p>
The class Disc<sub>item</sub> inherits the net<sub>price</sub> function from Item<sub>base</sub> but does not redefine
it. This class exists solely for other classes to inherit from it.
</p>

<p>
We do not intend for users to define Disc<sub>item</sub> objects. Instead, Disc<sub>item</sub> objects should exist
<b><b>only as part of an object of a type derived</b></b> from Disc<sub>item</sub>.
</p>

<p>
We can enforce this design intent by making ent<sub>price</sub> a <b><b>pure</b></b> <b><b>virtual</b></b> <b><b>function</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Disc_item</span> : <span style="color: #fa8072;">public</span> <span style="color: #9acd32; font-weight: bold;">Item_base</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #9acd32; font-weight: bold;">double</span> <span style="color: #7fffd4; font-weight: bold;">net_price</span>(<span style="color: #7fffd4;">std</span>::size_t) <span style="color: #fa8072;">const</span> = 0;
};
</pre>
</div>

<p>
Defining a virtual as pure indicates that the function <b><b>provides</b></b> <b><b>an</b></b> <b><b>interface</b></b> for subsequent
types <b><b>to</b></b> <b><b>override</b></b> but that <b><b>the</b></b> <b><b>version</b></b> <b><b>in</b></b> <b><b>this</b></b> <b><b>class</b></b> <b><b>will</b></b> <b><b>never</b></b> <b><b>be</b></b> <b><b>called</b></b>.
</p>

<p>
A class containing (or inheriting) one or more pure virtual functions is an <b><b>abstract base
class</b></b>. We may not create objects of an abstract type except as parts of objects of classes
derived from the abstract base.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfbea7a5" class="outline-3">
<h3 id="orgfbea7a5"><span class="section-number-3">12.4</span> Name Lookup and Inheritance</h3>
<div class="outline-text-3" id="text-12-4">
<ol class="org-ol">
<li>Start by determining the static type of object, reference, or pointer through which the
function is called.</li>
<li>Look for the function in that class. If it is not found, look in the immediate base class
and continue up the chain of classes until either the function is found or the last class is
searched.</li>
<li>Once the name is found, do normal type-checking to see if this call is legal given the
definition that was found.</li>
<li>Assuming the call is legal, the compiler generates code. If the function is virtual and the
call is through a reference or pointer, then the compiler generates code to determine which
version to run based on the dynamic type of the object. Otherwise, the compiler generates
code to call the function directly.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org275e6f1" class="outline-2">
<h2 id="org275e6f1"><span class="section-number-2">13</span> Template Definitions</h2>
<div class="outline-text-2" id="text-13">
</div>
<div id="outline-container-org9a2f7f1" class="outline-3">
<h3 id="org9a2f7f1"><span class="section-number-3">13.1</span> Function Template</h3>
<div class="outline-text-3" id="text-13-1">
</div>
<div id="outline-container-org9eab547" class="outline-4">
<h4 id="org9eab547"><span class="section-number-4">13.1.1</span> Defining</h4>
<div class="outline-text-4" id="text-13-1-1">
<p>
A function template is a type-independent function that is used as formula for generating a
type-specific version of the function.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">template</span> &lt;<span style="color: #fa8072;">typename</span> <span style="color: #9acd32; font-weight: bold;">T</span>&gt;
<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">compare</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">T</span> &amp;<span style="color: #7fffd4; font-weight: bold;">v1</span>, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">T</span> &amp;<span style="color: #7fffd4; font-weight: bold;">v2</span>) {
  <span style="color: #fa8072;">if</span> (v1 &lt; v2) <span style="color: #fa8072;">return</span> -1;
  <span style="color: #fa8072;">if</span> (v2 &lt; v1) <span style="color: #fa8072;">return</span> 1;
  <span style="color: #fa8072;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd50389d" class="outline-4">
<h4 id="orgd50389d"><span class="section-number-4">13.1.2</span> Using</h4>
<div class="outline-text-4" id="text-13-1-2">
<p>
int main() {
cout &lt;&lt; compare (1, 0) &lt;&lt; endl;
string s1 = "hi", s2 = "world";
cout &lt;&lt; compare (s1, s2) &lt;&lt; endl;
return 0;
}
</p>
</div>
</div>

<div id="outline-container-orgc65f9f9" class="outline-4">
<h4 id="orgc65f9f9"><span class="section-number-4">13.1.3</span> inline Function Templates</h4>
<div class="outline-text-4" id="text-13-1-3">
<p>
&lt;src lang="emacs-lisp"&gt;
// ok: inline specifier follows template parameter list
template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);
// error: incorrect placement of inline specifier
inline template &lt;typename T&gt; T min(const T&amp;, const T&amp;);
#+end<sub>src</sub>
</p>
</div>
</div>
</div>

<div id="outline-container-org9ea3e5c" class="outline-3">
<h3 id="org9ea3e5c"><span class="section-number-3">13.2</span> Class Template</h3>
<div class="outline-text-3" id="text-13-2">
</div>
<div id="outline-container-orgdb3df9e" class="outline-4">
<h4 id="orgdb3df9e"><span class="section-number-4">13.2.1</span> Defining</h4>
<div class="outline-text-4" id="text-13-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">template</span> &lt;<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Type</span>&gt; <span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Queue</span> {
<span style="color: #fa8072;">public</span>:
  <span style="color: #7fffd4; font-weight: bold;">Queue</span>();
  <span style="color: #9acd32; font-weight: bold;">Type</span> &amp;<span style="color: #7fffd4; font-weight: bold;">front</span> ();             <span style="color: #add8e6;">// </span><span style="color: #add8e6;">return element from head of Queue</span>
  <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Type</span> &amp;<span style="color: #7fffd4; font-weight: bold;">front</span> () <span style="color: #fa8072;">const</span>;
  <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">push</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Type</span> &amp;);   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">add element to back of Queue</span>
<span style="color: #fa8072;">private</span>:
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
};
</pre>
</div>

<p>
with the exception of the template parameter list, the definition of a class template looks like
any other class.
</p>
</div>
</div>

<div id="outline-container-org8dafd64" class="outline-4">
<h4 id="org8dafd64"><span class="section-number-4">13.2.2</span> Using</h4>
<div class="outline-text-4" id="text-13-2-2">
<p>
When we use a class template, we must explicitly specify arguments for the template
parameters.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">Queue</span>&lt;<span style="color: #9acd32; font-weight: bold;">int</span>&gt; <span style="color: #7fffd4; font-weight: bold;">qi</span>;
<span style="color: #9acd32; font-weight: bold;">Queue</span>&lt; <span style="color: #9acd32; font-weight: bold;">vector</span>&lt;<span style="color: #9acd32; font-weight: bold;">double</span>&gt; &gt; <span style="color: #7fffd4; font-weight: bold;">qc</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4b9b4a9" class="outline-3">
<h3 id="org4b9b4a9"><span class="section-number-3">13.3</span> Template Parameters</h3>
<div class="outline-text-3" id="text-13-3">
<ul class="org-ul">
<li>A name used as a template parameter may not be reused within the template:</li>
</ul>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">template</span> &lt;<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">T</span>&gt; <span style="color: #9acd32; font-weight: bold;">T</span> <span style="color: #7fffd4; font-weight: bold;">calc</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">T</span> &amp;<span style="color: #7fffd4; font-weight: bold;">a</span>, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">T</span> &amp;<span style="color: #7fffd4; font-weight: bold;">b</span>) {
  <span style="color: #fa8072;">typedef</span> <span style="color: #9acd32; font-weight: bold;">double</span>;     <span style="color: #add8e6;">// </span><span style="color: #add8e6;">error: redeclares template parameter T</span>
  <span style="color: #9acd32; font-weight: bold;">T</span> <span style="color: #7fffd4; font-weight: bold;">tmp</span> = a;
}
</pre>
</div>

<ul class="org-ul">
<li>As with any other function or class, we can declare a template without defining it.</li>
</ul>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">declares compare but does not define it</span>
<span style="color: #fa8072;">template</span> &lt;<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">T</span>&gt; <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">compare</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">T</span>&amp;, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">T</span>&amp;);
</pre>
</div>

<p>
The name of the template parameters <b>need not be the same</b> across declarations and the definition
of the same template.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">template</span> &lt;<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">T</span>&gt; <span style="color: #9acd32; font-weight: bold;">T</span> <span style="color: #7fffd4; font-weight: bold;">calc</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">T</span>&amp;, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">T</span>&amp;);
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
<span style="color: #fa8072;">template</span> &lt;<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Type</span>&gt;
<span style="color: #9acd32; font-weight: bold;">Type</span> <span style="color: #7fffd4; font-weight: bold;">calc</span> (<span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Type</span>&amp; <span style="color: #7fffd4; font-weight: bold;">a</span>, <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">Type</span>&amp; <span style="color: #7fffd4; font-weight: bold;">b</span>) { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;">*/</span> }
</pre>
</div>
</div>

<div id="outline-container-org4a4749a" class="outline-4">
<h4 id="org4a4749a"><span class="section-number-4">13.3.1</span> Nontype Template Parameters</h4>
<div class="outline-text-4" id="text-13-3-1">
<p>
Nontype parameters are replaced by values when the function is called.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">template</span> &lt;<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">T</span>, <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">N</span>&gt; <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">array_init</span> (<span style="color: #9acd32; font-weight: bold;">T</span> (&amp;<span style="color: #7fffd4; font-weight: bold;">parm</span>) [N] ) {
  <span style="color: #fa8072;">for</span> (<span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">i</span> = 0; i != N; i++) {
    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">....</span>
  }
}

<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">x</span>[42];
array_init(x);  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">instantiates array_init ( int (&amp;) [42] )</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orga5ecc9a" class="outline-2">
<h2 id="orga5ecc9a"><span class="section-number-2">14</span> Namespaces</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-org5bf53a7" class="outline-3">
<h3 id="org5bf53a7"><span class="section-number-3">14.1</span> Namespace Definitions</h3>
<div class="outline-text-3" id="text-14-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">namespace</span> <span style="color: #7fffd4;">cplusplus</span> {
  <span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Sales_item</span> {  <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> };
  <span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Query</span> {
  <span style="color: #fa8072;">public</span>:
    <span style="color: #7fffd4; font-weight: bold;">Query</span>(<span style="color: #fa8072;">const</span> <span style="color: #7fffd4;">std</span>::<span style="color: #9acd32; font-weight: bold;">string</span>&amp;);
    <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
  };
  <span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Query_base</span> { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> };
}
</pre>
</div>

<p>
Namespaces may be defined at global scope or inside another namespace. They may <b><b>not</b></b> be <b><b>defined</b></b>
<b><b>inside</b></b> <b><b>a</b></b> <b><b>function</b></b> <b><b>or</b></b> <b><b>a</b></b> <b><b>class</b></b>. Any declaration that can appear at global scope can be put into a
namespace.
</p>
</div>
</div>
</div>

<div id="outline-container-org36eafd0" class="outline-2">
<h2 id="org36eafd0"><span class="section-number-2">15</span> update</h2>
<div class="outline-text-2" id="text-15">
</div>
<div id="outline-container-orgc43492e" class="outline-3">
<h3 id="orgc43492e"><span class="section-number-3">15.1</span> Virtuelle Funktionen</h3>
<div class="outline-text-3" id="text-15-1">
<p>
Denken Sie an ein Programm, das mit einfachen geometrischen Figuren, z. B. Kreisen und
Dreiecken, umgehen soll. Nutzen wir die Möglichkeiten der Vererbung, bieten sich folgende
Klassendeklarationen an:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Figur</span> {
<span style="color: #fa8072;">protected</span>:
  <span style="color: #9acd32; font-weight: bold;">Punkt</span> <span style="color: #7fffd4; font-weight: bold;">mittelpunkt</span>;
  <span style="color: #9acd32; font-weight: bold;">Farbe</span> <span style="color: #7fffd4; font-weight: bold;">farbe</span>;
<span style="color: #fa8072;">public</span>:
  <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">verschiebenUm</span>(<span style="color: #9acd32; font-weight: bold;">Punkt</span> <span style="color: #7fffd4; font-weight: bold;">v</span>) { mittelpunkt += v; }
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
};

<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Dreieck</span> : <span style="color: #fa8072;">public</span> <span style="color: #9acd32; font-weight: bold;">Figur</span> {
<span style="color: #fa8072;">protected</span>:
  <span style="color: #9acd32; font-weight: bold;">Punkt</span> <span style="color: #7fffd4; font-weight: bold;">ecke</span>[3];
<span style="color: #fa8072;">public</span>:
  <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">verschiebenUm</span>(<span style="color: #9acd32; font-weight: bold;">Punkt</span> <span style="color: #7fffd4; font-weight: bold;">v</span>);
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
};

<span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Kreis</span> : <span style="color: #fa8072;">public</span> <span style="color: #9acd32; font-weight: bold;">Figur</span> {
<span style="color: #fa8072;">protected</span>:
  <span style="color: #9acd32; font-weight: bold;">float</span> <span style="color: #7fffd4; font-weight: bold;">radius</span>;
<span style="color: #fa8072;">public</span>:
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
};
</pre>
</div>

<p>
Dabei nehmen wir an, dass Klassen Punkt und Farbe mit der jeweils erforderlichen Funktionalität
zur Verfügung stehen.
</p>

<p>
Die Klasse Dreieck kann die ererbte Methode verschiebenUm überschreiben:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4;">Dreieck</span>::<span style="color: #7fffd4; font-weight: bold;">verschiebenUm</span>(<span style="color: #9acd32; font-weight: bold;">Punkt</span> <span style="color: #7fffd4; font-weight: bold;">v</span>) {
  <span style="color: #7fffd4;">Figur</span>::verschiebenUm(v);                  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Mittelpunkt verschieben</span>
  <span style="color: #fa8072;">for</span> (<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span> = 0; i &lt; 3; i++)               <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Ecken verschieben</span>
    ecke[i] += v;
}
</pre>
</div>

<p>
Bei der Klasse Kreis ist nichts weiter zu tun.
</p>

<p>
Stellen Sie sich jetzt aber vor, der Benutzer hätte (z. B. im Rahmen einer grafischen
Bedienoberfläche: mit der Maus) einige solcher Objekte erzeugt, die unser Programm in einer
Liste verwaltet, und wollte nun alle gemeinsam verschieben. Es handelt sich durchwegs um
Figuren, aber zum Verschieben muss je nach exakter Klasse eine unterschiedliche Methode
aufgerufen werden. C++ stellt hierfür das Konzept der virtuellen Funktion (virtual function) zur
Verfügung. Kennzeichnen Sie die Methode in der Basisklasse mit dem Schlüsselwort <b>virtual</b>:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #fa8072;">class</span> <span style="color: #9acd32; font-weight: bold;">Figur</span> {
  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">...</span>
  <span style="color: #fa8072;">virtual</span> <span style="color: #9acd32; font-weight: bold;">void</span> <span style="color: #7fffd4; font-weight: bold;">verschiebenUm</span>(<span style="color: #9acd32; font-weight: bold;">Punkt</span> <span style="color: #7fffd4; font-weight: bold;">v</span>) { <span style="color: #add8e6;">/* </span><span style="color: #add8e6;">...</span><span style="color: #add8e6;"> */</span> }
};
</pre>
</div>

<p>
so wird die <b><b>"passende" Methode</b></b> nicht von der statischen Typüberprüfung des Compilers festgelegt,
sondern <b><b>erst zur Laufzeit entschieden</b></b>.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">Figur</span> *<span style="color: #7fffd4; font-weight: bold;">figur</span>[10]; <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Array von 10 Zeigern auf Figur</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">... Figuren erzeugen, alle haben die Basisklasse "Figur"</span>
<span style="color: #9acd32; font-weight: bold;">Punkt</span> <span style="color: #7fffd4; font-weight: bold;">v</span>(5, 3); <span style="color: #add8e6;">// </span><span style="color: #add8e6;">Verschiebungsvektor</span>
<span style="color: #fa8072;">for</span> (<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">i</span> = 0; i &lt; 10; i++)
  figur[i]-&gt;verschiebenUm(v);
</pre>
</div>

<p>
Wenn figur[i] auf einen Kreis zeigt, wird Kreis::verschiebenUm ausgeführt; zeigt er auf ein
Dreieck, statt dessen Dreieck::verschiebenUm. Ohne dass Sie irgendeine Bedingung abprüfen oder
einen dynamic<sub>cast</sub> probieren müssten! Ebenso einfach wie durchschlagskräftig.
</p>

<p>
Ein weiterer großer Vorteil: wenn Sie später einmal eine neue Figurenklasse ableiten wollen,
etwa Quadrat, müssen Sie tatsächlich nur die Implementation dieser Klasse neu schreiben. Ihr
vorhandener Code, der mit der polymorphen Figur-Klasse arbeitet, kann bleiben wie er ist und
wird auch mit der zusätzlichen Klasse funktionieren.
</p>

<p>
Sie werden jetzt vielleicht fragen, weshalb dieses mächtige Werkzeug – man spricht auch von
später Bindung (late binding), weil die Zuordnung von Methodenname zu Implementation erst zur
Laufzeit vorgenommen wird – mit einem Schlüsselwort extra "eingeschaltet" werden
muss. Polymorphie verursacht mehr Verwaltungsaufwand für das Laufzeitsystem: Objekte einer
polymorphen Klasse müssen einen "Rucksack" mit Funktionszeigern (die so genannte virtual
function table) mit sich herumtragen, und jeder Methodenaufruf erfordert eine zusätzliche
Zeigerdereferenzierung.
</p>
</div>
</div>

<div id="outline-container-org77a75ad" class="outline-3">
<h3 id="org77a75ad"><span class="section-number-3">15.2</span> istream</h3>
<div class="outline-text-3" id="text-15-2">
</div>
<div id="outline-container-org9a8238d" class="outline-4">
<h4 id="org9a8238d"><span class="section-number-4">15.2.1</span> seekg</h4>
<div class="outline-text-4" id="text-15-2-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">istream</span>&amp; <span style="color: #7fffd4; font-weight: bold;">seekg</span> ( <span style="color: #9acd32; font-weight: bold;">streampos</span> <span style="color: #7fffd4; font-weight: bold;">pos</span> );
<span style="color: #9acd32; font-weight: bold;">istream</span>&amp; <span style="color: #7fffd4; font-weight: bold;">seekg</span> ( <span style="color: #9acd32; font-weight: bold;">streamoff</span> <span style="color: #7fffd4; font-weight: bold;">off</span>, <span style="color: #7fffd4;">ios_base</span>::<span style="color: #9acd32; font-weight: bold;">seekdir</span> <span style="color: #7fffd4; font-weight: bold;">dir</span> );
</pre>
</div>

<p>
Parameters
</p>

<ul class="org-ul">
<li>pos: The new position in the stream buffer. This parameter is an integral value of type streampos.</li>
<li>off: Integral value of type streamoff representing the offset to be applied relative to an
absolute position specified in the dir parameter.</li>
<li>dir: Seeking direction. It is an object of type ios<sub>base</sub>::seekdir that specifies an absolute
position from where the offset parameter off is applied. It can take any of the following
member constant values:</li>
<li>ios<sub>base</sub>::beg beginning of the stream buffer</li>
<li>ios<sub>base</sub>::cur current position in the stream buffer</li>
<li>ios<sub>base</sub>::end end of the stream buffer</li>
</ul>

<p>
Return Value
</p>

<p>
The function returns *this. Errors are signaled by modifying the internal state flags.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">load a file into memory</span>
<span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #fa8072; font-weight: bold;">#include</span> <span style="color: #ffa07a;">&lt;fstream&gt;</span>
<span style="color: #fa8072;">using</span> <span style="color: #fa8072;">namespace</span> <span style="color: #7fffd4;">std</span>;

<span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">main</span> () {
  <span style="color: #9acd32; font-weight: bold;">int</span> <span style="color: #7fffd4; font-weight: bold;">length</span>;
  <span style="color: #9acd32; font-weight: bold;">char</span> * <span style="color: #7fffd4; font-weight: bold;">buffer</span>;

  <span style="color: #9acd32; font-weight: bold;">ifstream</span> <span style="color: #7fffd4; font-weight: bold;">is</span>;
  is.open (<span style="color: #ffa07a;">"test.txt"</span>, <span style="color: #7fffd4;">ios</span>::binary );

  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">get length of file:</span>
  is.seekg (0, <span style="color: #7fffd4;">ios</span>::end);
  length = is.tellg();
  is.seekg (0, <span style="color: #7fffd4;">ios</span>::beg);

  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">allocate memory:</span>
  buffer = <span style="color: #fa8072;">new</span> <span style="color: #9acd32; font-weight: bold;">char</span> [length];

  <span style="color: #add8e6;">// </span><span style="color: #add8e6;">read data as a block:</span>
  is.read (buffer,length);

  is.close();

  cout.write (buffer,length);

  <span style="color: #fa8072;">delete</span>[] buffer;
  <span style="color: #fa8072;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org08185e0" class="outline-4">
<h4 id="org08185e0"><span class="section-number-4">15.2.2</span> tellg</h4>
<div class="outline-text-4" id="text-15-2-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">streampos</span> <span style="color: #7fffd4; font-weight: bold;">tellg</span> ( );
</pre>
</div>

<p>
Returns the absolute position of the get pointer.
</p>

<ul class="org-ul">
<li>Return Value</li>
</ul>

<p>
An integral value of type streampos with the number of characters between the beginning of the
input sequence and the current position.
</p>

<p>
Failure is indicated by returning a value of -1.
</p>
</div>
</div>
</div>

<div id="outline-container-orga97cf01" class="outline-3">
<h3 id="orga97cf01"><span class="section-number-3">15.3</span> string</h3>
<div class="outline-text-3" id="text-15-3">
</div>
<div id="outline-container-orgd2a7e16" class="outline-4">
<h4 id="orgd2a7e16"><span class="section-number-4">15.3.1</span> find</h4>
<div class="outline-text-4" id="text-15-3-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">find</span> ( <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">string</span>&amp; <span style="color: #7fffd4; font-weight: bold;">str</span>, <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">pos</span> = 0 ) <span style="color: #fa8072;">const</span>;
<span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">find</span> ( <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">char</span>* <span style="color: #7fffd4; font-weight: bold;">s</span>, <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">pos</span>, <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">n</span> ) <span style="color: #fa8072;">const</span>;
<span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">find</span> ( <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">char</span>* <span style="color: #7fffd4; font-weight: bold;">s</span>, <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">pos</span> = 0 ) <span style="color: #fa8072;">const</span>;
<span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">find</span> ( <span style="color: #9acd32; font-weight: bold;">char</span> <span style="color: #7fffd4; font-weight: bold;">c</span>, <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">pos</span> = 0 ) <span style="color: #fa8072;">const</span>;
</pre>
</div>

<p>
Searches the string for the content specified in either str, s or c, and returns the position of
the first occurrence in the string.
</p>

<p>
When pos is specified the search only includes characters on or after position pos, ignoring any
possible occurrences in previous locations.
</p>

<p>
Notice that unlike member find<sub>first</sub><sub>of</sub>, whenever more than one character is being searched for,
it is not enough that only one of these characters match, but the entire sequence of characters
to find must be matched.
</p>

<ul class="org-ul">
<li>str : string to be searched for in the object. The entire content of str must be matched in
some part of the string to be considered a match.</li>
<li>s : Array with a sequence of characters.</li>
<li>n : Length of sequence of characters to search for.</li>
<li>c : Individual character to be searched for.</li>
<li>pos : Position of the first character in the string to be taken into consideration for
possible matches. A value of 0 means that the entire string is considered.</li>
</ul>

<p>
Return Value
</p>

<p>
The position of the first occurrence in the string of the searched content. If the content is
not found, the member value <b><b>npos</b></b> is returned.
</p>
</div>
</div>

<div id="outline-container-org3763a8f" class="outline-4">
<h4 id="org3763a8f"><span class="section-number-4">15.3.2</span> npos</h4>
<div class="outline-text-4" id="text-15-3-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #7fffd4;">string</span>::npos  <span style="color: #fa8072;">static</span> member constant
<span style="color: #fa8072;">static</span> <span style="color: #fa8072;">const</span> <span style="color: #9acd32; font-weight: bold;">size_t</span> <span style="color: #7fffd4; font-weight: bold;">npos</span> = -1;
</pre>
</div>

<p>
Maximum value for size<sub>t</sub>
</p>

<p>
As a return value it is usually used to <b><b>indicate failure</b></b>.
</p>

<p>
This constant is actually defined with a value of <b><b>-1</b></b>, which because size<sub>t</sub> is an
<b><b>unsigned integral type</b></b>, becomes the largest possible representable value for this type.
</p>
</div>
</div>
</div>
</div>



<div id="outline-container-org3a9fe53" class="outline-2">
<h2 id="org3a9fe53"><span class="section-number-2">16</span> updated</h2>
<div class="outline-text-2" id="text-16">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #add8e6;">// </span><span style="color: #add8e6;">&#35774;&#32622;&#31934;&#24230;&#20026;2</span>
f1 = 0.12232;
cout.precision(2);
cout &lt;&lt; <span style="color: #ffa07a;">"f1 = "</span> &lt;&lt; f1 &lt;&lt; endl;   <span style="color: #add8e6;">// </span><span style="color: #add8e6;">output: 0.12</span>
<span style="color: #add8e6;">// </span><span style="color: #add8e6;">&#35299;&#38500;&#35774;&#23450;</span>
cout.precision();
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: Time-stamp: &lt;03/07/2021 edited by Lizhuo Chen&gt;</p>
<p class="author">Author: Lizhuo Chen</p>
<p class="date">Created: 2021-07-03 Sat 22:39</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
